// ----------------------------------------------------------------------------------
// MIT License
//
// Copyright (c) 2025 Sannr contributors
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// ----------------------------------------------------------------------------------

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Linq;
using System.Text;

namespace Sannr.Gen;

/// <summary>
/// Source generator for Sannr validators. Generates validation logic for attributed classes.
/// </summary>
[Generator]
public class SannrGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Initializes the generator and registers the validator generation pipeline.
    /// </summary>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classes = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (s, _) => s is PropertyDeclarationSyntax p && p.AttributeLists.Count > 0,
                transform: (ctx, _) => GetClassSemantic(ctx))
            .Where(m => m != null)
            .Collect()
            .SelectMany((c, _) => c.Distinct(SymbolEqualityComparer.Default).Cast<INamedTypeSymbol>());

        context.RegisterSourceOutput(classes, GenerateValidator!);
    }

    /// <summary>
    /// Gets the semantic symbol for a class containing a property with attributes.
    /// </summary>
    private static INamedTypeSymbol? GetClassSemantic(GeneratorSyntaxContext context)
    {
        if (context.Node is PropertyDeclarationSyntax prop &&
            prop.Parent is ClassDeclarationSyntax classDecl)
        {
             return context.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
        }
        return null;
    }

    /// <summary>
    /// Formats an error message for a validation attribute.
    /// </summary>
    private static string GetFormattedError(AttributeData attr, string defaultFormat, string nameVar, params string[] args)
    {
        string formatExpr = $"\"{defaultFormat}\"";
        var resType = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "ErrorMessageResourceType").Value.Value as INamedTypeSymbol;
        var resName = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "ErrorMessageResourceName").Value.Value as string;
        var explicitMsg = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "ErrorMessage").Value.Value as string;

        if (resType != null && !string.IsNullOrEmpty(resName))
            formatExpr = $"{resType.ToDisplayString()}.{resName}";
        else if (!string.IsNullOrEmpty(explicitMsg))
            formatExpr = $"\"{explicitMsg}\"";

        var sbArgs = new StringBuilder();
        sbArgs.Append(nameVar);
        foreach(var arg in args) sbArgs.Append(", " + arg);

        return $"string.Format({formatExpr}, {sbArgs.ToString()})";
    }

    /// <summary>
    /// Gets the severity value for a validation attribute.
    /// </summary>
    private static string GetSeverity(AttributeData attr)
    {
        var arg = attr.NamedArguments.FirstOrDefault(k => k.Key == "Severity");
        if (arg.Value.Value != null) return $"Severity.{(int)arg.Value.Value}";
        return "Severity.Error";
    }

    /// <summary>
    /// Generates the validator source code for a class symbol.
    /// </summary>
    private static void GenerateValidator(SourceProductionContext spc, INamedTypeSymbol classSymbol)
    {
        var className = classSymbol.Name;
        var ns = classSymbol.ContainingNamespace.ToDisplayString();
        var sb = new StringBuilder();

        sb.AppendLine($$"""
            // <auto-generated/>
            using System;
            using System.Threading.Tasks;
            using System.Text.RegularExpressions;
            using System.Runtime.CompilerServices;
            using Sannr;

            namespace {{ns}}
            {
                public static class {{className}}Validator
                {
                    private static readonly Regex _emailRgx = new Regex(@"^[^@\s]+@[^@\s]+\.[^@\s]+$", RegexOptions.Compiled);
                    private static readonly Regex _ccRgx = new Regex(@"^[\d\- ]{13,19}$", RegexOptions.Compiled);
                    private static readonly Regex _urlRgx = new Regex(@"^https?://", RegexOptions.Compiled);
                    private static readonly Regex _phoneRgx = new Regex(@"^[\d\s\-\+\(\)]+$", RegexOptions.Compiled);

                    public static async Task<ValidationResult> ValidateAsync(SannrValidationContext context)
                    {
                        var model = ({{className}})context.ObjectInstance;
                        var result = new ValidationResult();
                        var activeGroup = context.ActiveGroup;
            """);

        foreach (var member in classSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            var attributes = member.GetAttributes();
            var prop = member.Name;

            var sanAttr = attributes.FirstOrDefault(a => a.AttributeClass?.Name == "SanitizeAttribute");
            if (sanAttr != null)
            {
                bool trim = (bool)(sanAttr.NamedArguments.FirstOrDefault(k => k.Key == "Trim").Value.Value ?? false);
                bool upper = (bool)(sanAttr.NamedArguments.FirstOrDefault(k => k.Key == "ToUpper").Value.Value ?? false);
                bool lower = (bool)(sanAttr.NamedArguments.FirstOrDefault(k => k.Key == "ToLower").Value.Value ?? false);
                
                if (trim) sb.AppendLine($$"""if (model.{{prop}} != null) model.{{prop}} = model.{{prop}}.Trim();""");
                if (upper) sb.AppendLine($$"""if (model.{{prop}} != null) model.{{prop}} = model.{{prop}}.ToUpper();""");
                if (lower) sb.AppendLine($$"""if (model.{{prop}} != null) model.{{prop}} = model.{{prop}}.ToLower();""");
            }

            var displayAttr = attributes.FirstOrDefault(a => a.AttributeClass?.Name == "DisplayAttribute");
            var explicitName = displayAttr?.NamedArguments.FirstOrDefault(k => k.Key == "Name").Value.Value?.ToString();
            string nameVar = explicitName != null ? $"\"{explicitName}\"" : $"\"{prop}\"";

            foreach(var attr in attributes)
            {
                var attrName = attr.AttributeClass?.Name;
                var severity = GetSeverity(attr);
                var groupArg = attr.NamedArguments.FirstOrDefault(k => k.Key == "Group").Value.Value as string;
                if (groupArg != null) sb.AppendLine($$"""if (activeGroup == "{{groupArg}}") {""");

                if (attrName == "RequiredAttribute") {
                    var msg = GetFormattedError(attr, "{0} is required.", nameVar);
                    sb.AppendLine($$"""if (model.{{prop}} is null || (model.{{prop}} is string s_{{prop}} && string.IsNullOrWhiteSpace(s_{{prop}}))) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                }
                else if (attrName == "StringLengthAttribute") {
                    int max = (int)(attr.ConstructorArguments[0].Value ?? 0);
                    var msg = GetFormattedError(attr, "The field {0} must be a string with a maximum length of {1}.", nameVar, max.ToString());
                    sb.AppendLine($$"""if (model.{{prop}} is string str_{{prop}} && str_{{prop}}.Length > {{max}}) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                }
                else if (attrName == "RangeAttribute") {
                    var min = attr.ConstructorArguments[0].Value;
                    var max = attr.ConstructorArguments[1].Value;
                    var msg = GetFormattedError(attr, "The field {0} must be between {1} and {2}.", nameVar, min?.ToString() ?? "0", max?.ToString() ?? "0");
                    sb.AppendLine($$"""if (model.{{prop}} < (dynamic){{min}} || model.{{prop}} > (dynamic){{max}}) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                }
                else if (attrName == "EmailAddressAttribute") {
                    var msg = GetFormattedError(attr, "The {0} field is not a valid e-mail address.", nameVar);
                    sb.AppendLine($$"""if (model.{{prop}} != null && !_emailRgx.IsMatch(model.{{prop}}.ToString())) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                }
                else if (attrName == "CreditCardAttribute") {
                    var msg = GetFormattedError(attr, "The {0} field is not a valid credit card number.", nameVar);
                    sb.AppendLine($$"""if (model.{{prop}} != null && !_ccRgx.IsMatch(model.{{prop}}.ToString())) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                }
                else if (attrName == "RequiredIfAttribute") {
                    var other = attr.ConstructorArguments[0].Value?.ToString();
                    var val = attr.ConstructorArguments[1].Value;
                    string valStr = val is string s ? $"\"{s}\"" : (val?.ToString().ToLower() ?? "null");
                    var msg = GetFormattedError(attr, "{0} is required due to {{other}}.", nameVar);
                    sb.AppendLine($$"""if (object.Equals(model.{{other}}, {{valStr}}) && (model.{{prop}} is null || (model.{{prop}} is string s2_{{prop}} && string.IsNullOrWhiteSpace(s2_{{prop}})))) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                }
                else if (attrName == "CustomValidatorAttribute") {
                    var type = attr.ConstructorArguments[0].Value as INamedTypeSymbol;
                    var method = attr.ConstructorArguments[1].Value?.ToString() ?? "Check";
                    var isAsync = (bool)(attr.NamedArguments.FirstOrDefault(k => k.Key == "IsAsync").Value.Value ?? false);
                    if (type != null) {
                        string call = isAsync 
                            ? $"await {type.ToDisplayString()}.{method}(model.{prop}, context.ServiceProvider)"
                            : $"{type.ToDisplayString()}.{method}(model.{prop}, context.ServiceProvider)";
                        sb.AppendLine($$"""var customRes_{{prop}} = {{call}}; result.Merge(customRes_{{prop}}, "{{prop}}");""");
                    }
                }
                if (groupArg != null) sb.AppendLine("}");
            }
        }

        sb.AppendLine($$"""
                        return result;
                    }
                }
                internal static class {{className}}SannrLoader
                {
                    [ModuleInitializer]
                    internal static void Load()
                    {
                        SannrValidatorRegistry.Register(typeof({{className}}), async (ctx) => await {{className}}Validator.ValidateAsync(ctx));
                    }
                }
            }
            """);
        spc.AddSource($"{className}.SannrValidator.g.cs", sb.ToString());
    }
}
