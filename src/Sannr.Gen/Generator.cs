// ----------------------------------------------------------------------------------
// MIT License
//
// Copyright (c) 2025 Sannr contributors
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// ----------------------------------------------------------------------------------

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System;

namespace Sannr.Gen;

/// <summary>
/// Minimal test generator to verify analyzer loading.
/// </summary>
[Generator]
public class TestGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // No-op
    }

    public void Execute(GeneratorExecutionContext context)
    {
        context.AddSource("TestGenerated.g.cs", "// Test generated code");
    }
}

/// <summary>
/// Source generator for Sannr validators. Generates validation logic for attributed classes.
/// </summary>
[Generator]
public class SannrGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Initializes the generator and registers the validator generation pipeline.
    /// </summary>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Simple test: Always add a source file to verify generator is running
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource("TestGenerator.g.cs", "// Test: Generator is working!"));

        // Enhanced incremental validator generation pipeline
        var validatorProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (s, _) => IsValidationTarget(s),
                transform: (ctx, _) => GetValidationTarget(ctx))
            .Where(m => m != null)
            .Collect()
            .Select((targets, _) => ProcessValidationTargets(targets!));

        context.RegisterSourceOutput(validatorProvider, GenerateValidators!);
    }

    /// <summary>
    /// Generates diagnostic helper methods for the source generator.
    /// </summary>
    private static string GenerateDiagnosticHelpers()
    {
        return """
            // <auto-generated/>
            // Sannr Generator Diagnostic Helpers
            using Microsoft.CodeAnalysis;

            namespace Sannr.Gen.Diagnostics
            {
                internal static class DiagnosticDescriptors
                {
                    public static readonly DiagnosticDescriptor InvalidAttributeUsage = new DiagnosticDescriptor(
                        id: "SANN001",
                        title: "Invalid attribute usage",
                        messageFormat: "Attribute '{0}' is not valid on property '{1}'",
                        category: "SannrGenerator",
                        defaultSeverity: DiagnosticSeverity.Error,
                        isEnabledByDefault: true);

                    public static readonly DiagnosticDescriptor UnsupportedAttribute = new DiagnosticDescriptor(
                        id: "SANN002",
                        title: "Unsupported attribute",
                        messageFormat: "Attribute '{0}' is not supported by Sannr generator",
                        category: "SannrGenerator",
                        defaultSeverity: DiagnosticSeverity.Warning,
                        isEnabledByDefault: true);

                    public static readonly DiagnosticDescriptor RegexCompilationError = new DiagnosticDescriptor(
                        id: "SANN003",
                        title: "Regex compilation error",
                        messageFormat: "Failed to compile regex pattern '{0}': {1}",
                        category: "SannrGenerator",
                        defaultSeverity: DiagnosticSeverity.Error,
                        isEnabledByDefault: true);
                }
            }
            """;
    }

    /// <summary>
    /// Determines if a syntax node is a potential validation target.
    /// </summary>
    private static bool IsValidationTarget(SyntaxNode node)
    {
        // Debug: Target all classes to see if generator runs
        return node is ClassDeclarationSyntax;
    }

    /// <summary>
    /// Gets validation target information from syntax context.
    /// </summary>
    private static INamedTypeSymbol? GetValidationTarget(GeneratorSyntaxContext context)
    {
        if (context.Node is ClassDeclarationSyntax classDecl)
        {
            var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
            if (classSymbol != null && HasValidationAttributes(classSymbol))
            {
                return classSymbol;
            }
        }
        return null;
    }

    /// <summary>
    /// Processes validation targets and returns distinct class symbols.
    /// </summary>
    private static ImmutableArray<INamedTypeSymbol> ProcessValidationTargets(ImmutableArray<INamedTypeSymbol> targets)
    {
        return targets.Distinct<INamedTypeSymbol>(SymbolEqualityComparer.Default).ToImmutableArray();
    }

    /// <summary>
    /// Generates validators for multiple class symbols.
    /// </summary>
    private static void GenerateValidators(SourceProductionContext context, ImmutableArray<INamedTypeSymbol> targets)
    {
        foreach (var classSymbol in targets)
        {
            GenerateValidator(context, classSymbol);
        }

        // Generate OpenAPI schema filter for AOT-compatible schema generation
        GenerateOpenApiFilter(context, targets);

        // Generate AddSannr extension method for automatic validator registration
        GenerateAddSannrMethod(context, targets);
    }

    /// <summary>
    /// Gets client validation target information from syntax context.
    /// </summary>
    private static INamedTypeSymbol? GetClientValidationTarget(GeneratorSyntaxContext context)
    {
        if (context.Node is ClassDeclarationSyntax classDecl)
        {
            var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
            if (classSymbol != null)
            {
                var hasAttribute = classSymbol.GetAttributes()
                    .Any(a => a.AttributeClass?.Name == "GenerateClientValidatorsAttribute");
                if (hasAttribute)
                {
                    return classSymbol;
                }
            }
        }
        return null;
    }

    /// <summary>
    /// Processes client validation targets and returns distinct class symbols.
    /// </summary>
    private static ImmutableArray<INamedTypeSymbol> ProcessClientValidationTargets(ImmutableArray<INamedTypeSymbol> targets)
    {
        return targets.Distinct<INamedTypeSymbol>(SymbolEqualityComparer.Default).ToImmutableArray();
    }

    /// <summary>
    /// Generates advanced client-side validators.
    /// </summary>
    private static void GenerateAdvancedClientValidators(
        SourceProductionContext context,
        ImmutableArray<INamedTypeSymbol> targets)
    {
        foreach (var classSymbol in targets)
        {
            GenerateClientValidators(context, classSymbol);
        }
    }

    /// <summary>
    /// Checks if a class symbol has validation attributes on its properties.
    /// </summary>
    private static bool HasValidationAttributes(INamedTypeSymbol classSymbol)
    {
        return classSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Any(prop => prop.GetAttributes().Any(attr =>
                attr.AttributeClass?.Name.EndsWith("Attribute") == true &&
                (attr.AttributeClass.Name.Contains("Required") ||
                 attr.AttributeClass.Name.Contains("StringLength") ||
                 attr.AttributeClass.Name.Contains("Range") ||
                 attr.AttributeClass.Name.Contains("EmailAddress") ||
                 attr.AttributeClass.Name.Contains("CreditCard") ||
                 attr.AttributeClass.Name.Contains("Url") ||
                 attr.AttributeClass.Name.Contains("Phone") ||
                 attr.AttributeClass.Name.Contains("FileExtensions") ||
                 attr.AttributeClass.Name.Contains("CustomValidator") ||
                 attr.AttributeClass.Name.Contains("RequiredIf") ||
                 attr.AttributeClass.Name.Contains("Sanitize"))));
    }

    /// <summary>
    /// Gets the semantic symbol for a class marked with GenerateClientValidatorsAttribute.
    /// </summary>
    private static INamedTypeSymbol? GetClientValidationClassSemantic(GeneratorSyntaxContext context)
    {
        if (context.Node is ClassDeclarationSyntax classDecl)
        {
            var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
            if (classSymbol != null)
            {
                var hasAttribute = classSymbol.GetAttributes()
                    .Any(a => a.AttributeClass?.Name == "GenerateClientValidatorsAttribute");
                if (hasAttribute)
                {
                    return classSymbol;
                }
            }
        }
        return null;
    }

    /// <summary>
    /// Gets the semantic symbol for a class containing a property with attributes.
    /// </summary>
    private static INamedTypeSymbol? GetClassSemantic(GeneratorSyntaxContext context)
    {
        if (context.Node is PropertyDeclarationSyntax prop &&
            prop.Parent is ClassDeclarationSyntax classDecl)
        {
             return context.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
        }
        return null;
    }

    /// <summary>
    /// Formats an error message for a validation attribute.
    /// </summary>
    private static string GetFormattedError(AttributeData attr, string defaultFormat, string nameVar, params string[] args)
    {
        string formatExpr = $"\"{defaultFormat}\"";
        var resType = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "ErrorMessageResourceType").Value.Value as INamedTypeSymbol;
        var resName = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "ErrorMessageResourceName").Value.Value as string;
        var explicitMsg = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "ErrorMessage").Value.Value as string;

        if (resType != null && !string.IsNullOrEmpty(resName))
            formatExpr = $"{resType.ToDisplayString()}.{resName}";
        else if (!string.IsNullOrEmpty(explicitMsg))
            formatExpr = $"\"{explicitMsg}\"";

        var sbArgs = new StringBuilder();
        sbArgs.Append(nameVar);
        foreach(var arg in args) sbArgs.Append(", " + arg);

        return $"string.Format({formatExpr}, {sbArgs.ToString()})";
    }

    /// <summary>
    /// Gets the severity value for a validation attribute.
    /// </summary>
    private static string GetSeverity(AttributeData attr)
    {
        var arg = attr.NamedArguments.FirstOrDefault(k => k.Key == "Severity");
        if (arg.Value.Value != null) return $"Severity.{(int)arg.Value.Value}";
        return "Severity.Error";
    }

    /// <summary>
    /// Generates the validator source code for a class symbol.
    /// </summary>
    private static void GenerateValidator(SourceProductionContext spc, INamedTypeSymbol classSymbol)
    {
        var className = classSymbol.Name;
        var ns = classSymbol.ContainingNamespace.ToDisplayString();
        var sb = new StringBuilder();

        sb.AppendLine($$"""
            // <auto-generated/>
            // Advanced Sannr Validator Generator v2.0
            // Generated: {{DateTime.Now:yyyy-MM-dd HH:mm:ss}}
            using System;
            using System.Threading.Tasks;
            using System.Text.RegularExpressions;
            using System.Runtime.CompilerServices;
            using Sannr;
            using Sannr.Core; // Integrate with core metrics for observability

            namespace {{ns}}
            {
                internal static class {{className}}Validator
                {
                    // Pre-compiled regex patterns for optimal performance
                    private static readonly Regex _emailRegex = new Regex(@"^[^@\s]+@[^@\s]+\.[^@\s]+$", RegexOptions.Compiled | RegexOptions.CultureInvariant);
                    private static readonly Regex _creditCardRegex = new Regex(@"^[\d\- ]{13,19}$", RegexOptions.Compiled | RegexOptions.CultureInvariant);
                    private static readonly Regex _urlRegex = new Regex(@"^https?://", RegexOptions.Compiled | RegexOptions.CultureInvariant);
                    private static readonly Regex _phoneRegex = new Regex(@"^[\d\s\-\+\(\)]+$", RegexOptions.Compiled | RegexOptions.CultureInvariant);

                    public static async Task<ValidationResult> ValidateAsync(SannrValidationContext context)
                    {
                        var model = ({{className}})context.ObjectInstance;
                        var result = new ValidationResult();
                        var activeGroup = context.ActiveGroup;
                        Metrics.ValidationEvents.Add(1); // Track validation events for observability
            """);

        foreach (var member in classSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            var attributes = member.GetAttributes();
            var prop = member.Name;

            var sanAttr = attributes.FirstOrDefault(a => a.AttributeClass?.Name == "SanitizeAttribute");
            if (sanAttr != null)
            {
                bool trim = (bool)(sanAttr.NamedArguments.FirstOrDefault(k => k.Key == "Trim").Value.Value ?? false);
                bool upper = (bool)(sanAttr.NamedArguments.FirstOrDefault(k => k.Key == "ToUpper").Value.Value ?? false);
                bool lower = (bool)(sanAttr.NamedArguments.FirstOrDefault(k => k.Key == "ToLower").Value.Value ?? false);
                
                if (trim) sb.AppendLine($$"""if (model.{{prop}} != null) model.{{prop}} = model.{{prop}}.Trim();""");
                if (upper) sb.AppendLine($$"""if (model.{{prop}} != null) model.{{prop}} = model.{{prop}}.ToUpper();""");
                if (lower) sb.AppendLine($$"""if (model.{{prop}} != null) model.{{prop}} = model.{{prop}}.ToLower();""");
            }

            var displayAttr = attributes.FirstOrDefault(a => a.AttributeClass?.Name == "DisplayAttribute");
            var explicitName = displayAttr?.NamedArguments.FirstOrDefault(k => k.Key == "Name").Value.Value?.ToString();
            string nameVar = explicitName != null ? $"\"{explicitName}\"" : $"\"{prop}\"";

            foreach(var attr in attributes)
            {
                var attrName = attr.AttributeClass?.Name;
                var severity = GetSeverity(attr);
                var groupArg = attr.NamedArguments.FirstOrDefault(k => k.Key == "Group").Value.Value as string;
                if (groupArg != null) sb.AppendLine($$"""if (activeGroup == "{{groupArg}}") {""");

                if (attrName == "RequiredAttribute") {
                    var msg = GetFormattedError(attr, "{0} is required.", nameVar);
                    var propType = member.Type;
                    bool isValueType = propType.IsValueType;
                    
                    if (isValueType) {
                        // For value types, Required always passes since they can't be null
                        // But we could add a check for default values if needed
                    } else {
                        // For reference types, check for null or empty strings
                        sb.AppendLine($$"""if (model.{{prop}} is null || (model.{{prop}} is string s_{{prop}} && string.IsNullOrWhiteSpace(s_{{prop}}))) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                    }
                }
                else if (attrName == "StringLengthAttribute") {
                    int max = (int)(attr.ConstructorArguments[0].Value ?? 0);
                    int min = 0;
                    var minArg = attr.NamedArguments.FirstOrDefault(k => k.Key == "MinimumLength");
                    if (minArg.Value.Value != null) min = (int)minArg.Value.Value;
                    var msg = GetFormattedError(attr, "The field {0} must be a string with a maximum length of {1}.", nameVar, max.ToString());
                    if (min > 0) {
                        sb.AppendLine($$"""if (model.{{prop}} is string str_{{prop}} && (str_{{prop}}.AsSpan().Length < {{min}} || str_{{prop}}.AsSpan().Length > {{max}})) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                    } else {
                        sb.AppendLine($$"""if (model.{{prop}} is string str_{{prop}} && str_{{prop}}.AsSpan().Length > {{max}}) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                    }
                }
                else if (attrName == "RangeAttribute") {
                    var min = attr.ConstructorArguments[0].Value;
                    var max = attr.ConstructorArguments[1].Value;
                    var msg = GetFormattedError(attr, "The field {0} must be between {1} and {2}.", nameVar, min?.ToString() ?? "0", max?.ToString() ?? "0");
                    sb.AppendLine($$"""if (model.{{prop}} < (dynamic){{min}} || model.{{prop}} > (dynamic){{max}}) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                }
                else if (attrName == "EmailAddressAttribute") {
                    var msg = GetFormattedError(attr, "The {0} field is not a valid e-mail address.", nameVar);
                    sb.AppendLine($$"""if (model.{{prop}} != null && !_emailRegex.IsMatch(model.{{prop}}.ToString())) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                }
                else if (attrName == "CreditCardAttribute") {
                    var msg = GetFormattedError(attr, "The {0} field is not a valid credit card number.", nameVar);
                    sb.AppendLine($$"""if (model.{{prop}} != null && !_creditCardRegex.IsMatch(model.{{prop}}.ToString())) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                }
                else if (attrName == "UrlAttribute") {
                    var msg = GetFormattedError(attr, "The {0} field is not a valid URL.", nameVar);
                    sb.AppendLine($$"""if (model.{{prop}} != null && !_urlRegex.IsMatch(model.{{prop}}.ToString())) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                }
                else if (attrName == "PhoneAttribute") {
                    var msg = GetFormattedError(attr, "The {0} field is not a valid phone number.", nameVar);
                    sb.AppendLine($$"""if (model.{{prop}} != null && !_phoneRegex.IsMatch(model.{{prop}}.ToString())) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                }
                else if (attrName == "FileExtensionsAttribute") {
                    var extensions = attr.NamedArguments.FirstOrDefault(k => k.Key == "Extensions").Value.Value as string ?? "png,jpg,jpeg,gif";
                    var extArray = extensions.Split(',').Select(e => e.Trim().ToLower()).Where(e => !string.IsNullOrEmpty(e)).ToArray();
                    var extList = string.Join(", ", extArray.Select(e => "."+e));
                    // Build all parts as separate strings
                    var msgText = "The {0} field must have one of the following extensions: " + extList + ".";
                    var msgPart = "string.Format(\"" + msgText + "\", " + nameVar + ")";
                    var condParts = new System.Collections.Generic.List<string>();
                    foreach (var ext in extArray) {
                        condParts.Add("!model." + prop + ".ToString().ToLower().EndsWith(\"." + ext + "\")");
                    }
                    var conditionStr = string.Join(" && ", condParts);
                    sb.AppendLine("if (model." + prop + " != null && (" + conditionStr + ")) result.Add(\"" + prop + "\", " + msgPart + ", " + severity + ");");
                }
                else if (attrName == "RequiredIfAttribute") {
                    var other = attr.ConstructorArguments[0].Value?.ToString();
                    var val = attr.ConstructorArguments[1].Value;
                    string valStr;
                    if (val is string s) {
                        valStr = $"\"{s}\"";
                    } else if (val == null) {
                        valStr = "null";
                    } else {
                        valStr = val.ToString();
                        if (val is bool) valStr = valStr.ToLower();
                    }
                    var msg = GetFormattedError(attr, "{0} is required.", nameVar);
                    
                    // Check if the property type is a string
                    var propType = member.Type;
                    bool isStringType = propType.SpecialType == SpecialType.System_String;
                    
                    if (isStringType) {
                        sb.AppendLine($$"""if (object.Equals(model.{{other}}, {{valStr}}) && (model.{{prop}} is null || string.IsNullOrWhiteSpace(model.{{prop}}))) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                    } else {
                        // For non-string types, just check if the condition is met
                        sb.AppendLine($$"""if (object.Equals(model.{{other}}, {{valStr}}) && model.{{prop}} is null) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                    }
                }
                else if (attrName == "CustomValidatorAttribute") {
                    var type = attr.ConstructorArguments[0].Value as INamedTypeSymbol;
                    var method = attr.ConstructorArguments[1].Value?.ToString() ?? "Check";
                    var isAsync = (bool)(attr.NamedArguments.FirstOrDefault(k => k.Key == "IsAsync").Value.Value ?? false);
                    if (type != null) {
                        string call = isAsync 
                            ? $"await {type.ToDisplayString()}.{method}(model.{prop}, context.ServiceProvider)"
                            : $"{type.ToDisplayString()}.{method}(model.{prop}, context.ServiceProvider)";
                        sb.AppendLine($$"""var customRes_{{prop}} = {{call}}; result.Merge(customRes_{{prop}}, "{{prop}}");""");
                    }
                }
                if (groupArg != null) sb.AppendLine("}");
            }
        }

        // Check if the class implements IValidatableObject
        var iValidatableObjectInterface = classSymbol.AllInterfaces.FirstOrDefault(i => i.Name == "IValidatableObject" && i.ContainingNamespace.Name == "Sannr");
        if (iValidatableObjectInterface != null)
        {
            sb.AppendLine($$"""
                        // Call IValidatableObject.Validate if implemented
                        if (model is Sannr.IValidatableObject validatable)
                        {
                            var modelResults = validatable.Validate(context);
                            foreach (var modelResult in modelResults)
                            {
                                result.Add(modelResult.MemberName ?? "", modelResult.Message, modelResult.Severity);
                            }
                        }
            """);
        }

        sb.AppendLine($$"""
                        return result;
                    }
                }
                internal static class {{className}}SannrLoader
                {
                    [ModuleInitializer]
                    internal static void Load()
                    {
                        SannrValidatorRegistry.Register(typeof({{className}}), async (ctx) => await {{className}}Validator.ValidateAsync(ctx));
                    }
                }
            }
            """);
        spc.AddSource($"{ns}.{className}.SannrValidator.g.cs", sb.ToString());
    }

    /// <summary>
    /// Generates an AOT-compatible OpenAPI schema filter using compile-time generation.
    /// </summary>
    private static void GenerateOpenApiFilter(SourceProductionContext context, ImmutableArray<INamedTypeSymbol> targets)
    {
        // Only generate the filter if there are targets in the AspNetCore namespace
        if (!targets.Any(t => t.ContainingNamespace.ToDisplayString().StartsWith("Sannr.AspNetCore")))
            return;

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// Sannr OpenAPI Schema Filter Generator");
        sb.AppendLine("// Generated: " + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"));
        sb.AppendLine("using Microsoft.OpenApi.Models;");
        sb.AppendLine("using Swashbuckle.AspNetCore.SwaggerGen;");
        sb.AppendLine("using System;");
        sb.AppendLine("");
        sb.AppendLine("namespace Sannr.AspNetCore");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// AOT-compatible OpenAPI schema filter generated at compile-time.");
        sb.AppendLine("    /// Applies validation rules to OpenAPI schemas without runtime reflection.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public class SannrGeneratedSchemaFilter : ISchemaFilter");
        sb.AppendLine("    {");
        sb.AppendLine("        public void Apply(OpenApiSchema schema, SchemaFilterContext context)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (schema.Properties == null || context.Type == null)");
        sb.AppendLine("                return;");
        sb.AppendLine("");
        sb.AppendLine("            var typeName = context.Type.FullName;");
        sb.AppendLine("            switch (typeName)");
        sb.AppendLine("            {");

        foreach (var classSymbol in targets)
        {
            var className = classSymbol.Name;
            var ns = classSymbol.ContainingNamespace.ToDisplayString();
            var fullName = $"{ns}.{className}";

            sb.AppendLine($"                case \"{fullName}\":");
            sb.AppendLine($"                    Apply{className}Schema(schema);");
            sb.AppendLine("                    break;");
        }

        sb.AppendLine("            }");
        sb.AppendLine("        }");

        // Generate the Apply methods for each class
        foreach (var classSymbol in targets)
        {
            var className = classSymbol.Name;
            sb.AppendLine($"");
            sb.AppendLine($"        private static void Apply{className}Schema(OpenApiSchema schema)");
            sb.AppendLine("        {");
            sb.AppendLine("            OpenApiSchema propertySchema;");

            foreach (var member in classSymbol.GetMembers().OfType<IPropertySymbol>())
            {
                var attributes = member.GetAttributes();
                var prop = member.Name;

                sb.AppendLine($"            if (schema.Properties.TryGetValue(\"{prop}\", out propertySchema))");
                sb.AppendLine("            {");

                foreach (var attr in attributes)
                {
                    var attrName = attr.AttributeClass?.Name;
                    if (attrName == "RequiredAttribute")
                    {
                        // Required is handled at object level
                    }
                    else if (attrName == "StringLengthAttribute")
                    {
                        int max = (int)(attr.ConstructorArguments[0].Value ?? 0);
                        int min = 0;
                        var minArg = attr.NamedArguments.FirstOrDefault(k => k.Key == "MinimumLength");
                        if (minArg.Value.Value != null) min = (int)minArg.Value.Value;
                        if (max > 0) sb.AppendLine($"                propertySchema.MaxLength = {max};");
                        if (min > 0) sb.AppendLine($"                propertySchema.MinLength = {min};");
                    }
                    else if (attrName == "RangeAttribute")
                    {
                        var min = attr.ConstructorArguments[0].Value;
                        var max = attr.ConstructorArguments[1].Value;
                        if (min != null) sb.AppendLine($"                propertySchema.Minimum = (decimal){min};");
                        if (max != null) sb.AppendLine($"                propertySchema.Maximum = (decimal){max};");
                    }
                    else if (attrName == "EmailAddressAttribute")
                    {
                        sb.AppendLine("                propertySchema.Format = \"email\";");
                    }
                    else if (attrName == "UrlAttribute")
                    {
                        sb.AppendLine("                propertySchema.Format = \"uri\";");
                    }
                    else if (attrName == "FileExtensionsAttribute")
                    {
                        sb.AppendLine("                propertySchema.Format = \"file\";");
                    }
                    else if (attrName == "PhoneAttribute")
                    {
                        // No standard format
                    }
                    else if (attrName == "CreditCardAttribute")
                    {
                        // No standard format
                    }
                }

                sb.AppendLine("            }");
            }

            sb.AppendLine("        }");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource("SannrGeneratedSchemaFilter.g.cs", sb.ToString());
    }

    /// <summary>
    /// Generates client-side validation code for a class marked with GenerateClientValidatorsAttribute.
    /// </summary>
    private static void GenerateClientValidators(SourceProductionContext spc, INamedTypeSymbol classSymbol)
    {
        var className = classSymbol.Name;
        var ns = classSymbol.ContainingNamespace.ToDisplayString();

        // Get the attribute to determine output settings
        var attribute = classSymbol.GetAttributes()
            .First(a => a.AttributeClass?.Name == "GenerateClientValidatorsAttribute");

        var language = (int)(attribute.NamedArguments.FirstOrDefault(k => k.Key == "Language").Value.Value ?? 0);
        var outputDir = attribute.NamedArguments.FirstOrDefault(k => k.Key == "OutputDirectory").Value.Value as string;
        var generateFunctions = (bool)(attribute.NamedArguments.FirstOrDefault(k => k.Key == "GenerateValidationFunctions").Value.Value ?? true);
        var customNamespace = attribute.NamedArguments.FirstOrDefault(k => k.Key == "Namespace").Value.Value as string;

        var clientNamespace = customNamespace ?? ns.ToLower().Replace(".", "_");

        var sb = new StringBuilder();

        // Generate TypeScript interface
        sb.AppendLine($"// <auto-generated/>");
        sb.AppendLine($"// Generated from {ns}.{className}");
        sb.AppendLine();
        sb.AppendLine($"export interface {className} {{");

        // Generate interface properties
        foreach (var member in classSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            var propName = ToCamelCase(member.Name);
            var propType = GetTypeScriptType(member.Type);
            var isOptional = !IsRequiredProperty(member);

            sb.AppendLine($"    {propName}{(isOptional ? "?" : "")}: {propType};");
        }

        sb.AppendLine("}");
        sb.AppendLine();

        // Generate validation rules object
        sb.AppendLine($"export const {ToCamelCase(className)}Validators = {{");

        foreach (var member in classSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            var propName = ToCamelCase(member.Name);
            var rules = GetClientValidationRules(member);

            if (!string.IsNullOrEmpty(rules))
            {
                sb.AppendLine($"    {propName}: {{ {rules} }},");
            }
        }

        sb.AppendLine("};");

        // Generate validation functions if requested
        if (generateFunctions)
        {
            sb.AppendLine();
            sb.AppendLine($"export function validate{className}(model: {className}): ValidationResult {{");
            sb.AppendLine("    const errors: string[] = [];");
            sb.AppendLine();
            sb.AppendLine($"    // Validate each property using the rules");
            sb.AppendLine($"    Object.keys({ToCamelCase(className)}Validators).forEach(key => {{");
            sb.AppendLine($"        const rules = {ToCamelCase(className)}Validators[key as keyof typeof {ToCamelCase(className)}Validators];");
            sb.AppendLine("        const value = model[key as keyof typeof model];");
            sb.AppendLine("        const fieldErrors = validateField(value, rules);");
            sb.AppendLine("        if (fieldErrors.length > 0) {");
            sb.AppendLine("            errors.push(...fieldErrors.map(err => `${key}: ${err}`));");
            sb.AppendLine("        }");
            sb.AppendLine("    });");
            sb.AppendLine();
            sb.AppendLine("    return {");
            sb.AppendLine("        isValid: errors.length === 0,");
            sb.AppendLine("        errors");
            sb.AppendLine("    };");
            sb.AppendLine("}");
            sb.AppendLine();
            sb.AppendLine("export interface ValidationResult {");
            sb.AppendLine("    isValid: boolean;");
            sb.AppendLine("    errors: string[];");
            sb.AppendLine("}");
            sb.AppendLine();
            sb.AppendLine("function validateField(value: any, rules: any): string[] {");
            sb.AppendLine("    const errors: string[] = [];");
            sb.AppendLine();
            sb.AppendLine("    if (rules.required && (value === null || value === undefined || value === '')) {");
            sb.AppendLine("        errors.push('This field is required');");
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine("    if (value !== null && value !== undefined && value !== '') {");
            sb.AppendLine(@"        if (rules.email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {");
            sb.AppendLine("            errors.push('Invalid email format');");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        if (rules.minLength !== undefined && value.length < rules.minLength) {");
            sb.AppendLine("            errors.push(`Minimum length is ${rules.minLength}`);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        if (rules.maxLength !== undefined && value.length > rules.maxLength) {");
            sb.AppendLine("            errors.push(`Maximum length is ${rules.maxLength}`);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        if (rules.min !== undefined && value < rules.min) {");
            sb.AppendLine("            errors.push(`Minimum value is ${rules.min}`);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        if (rules.max !== undefined && value > rules.max) {");
            sb.AppendLine("            errors.push(`Maximum value is ${rules.max}`);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        if (rules.pattern && !new RegExp(rules.pattern).test(value)) {");
            sb.AppendLine("            errors.push('Invalid format');");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        if (rules.url && !/^https?:\\/\\/.+/.test(value)) {");
            sb.AppendLine("            errors.push('Invalid URL format');");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        if (rules.allowedValues && !rules.allowedValues.includes(value)) {");
            sb.AppendLine("            errors.push(`Value must be one of: ${rules.allowedValues.join(', ')}`);");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine("    return errors;");
            sb.AppendLine("}");
        }

        // Determine file extension based on language
        var extension = language switch
        {
            0 => ".ts", // TypeScript
            1 => ".js", // JavaScript
            2 => ".json", // JSON
            _ => ".ts"
        };

        var fileName = $"{clientNamespace}.{className}.validators{extension}";
        spc.AddSource(fileName, sb.ToString());
    }

    /// <summary>
    /// Converts a property name to camelCase for JavaScript/TypeScript.
    /// </summary>
    private static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name ?? "";
        return char.ToLower(name[0]) + name.Substring(1);
    }

    /// <summary>
    /// Gets the TypeScript type for a .NET type.
    /// </summary>
    private static string GetTypeScriptType(ITypeSymbol type)
    {
        return type.SpecialType switch
        {
            SpecialType.System_String => "string",
            SpecialType.System_Int32 or SpecialType.System_Int64 or SpecialType.System_Int16 => "number",
            SpecialType.System_Decimal or SpecialType.System_Double or SpecialType.System_Single => "number",
            SpecialType.System_Boolean => "boolean",
            SpecialType.System_DateTime => "string", // ISO date string
            _ => type.Name.ToLower()
        };
    }

    /// <summary>
    /// Checks if a property is required based on its attributes.
    /// </summary>
    private static bool IsRequiredProperty(IPropertySymbol property)
    {
        return property.GetAttributes().Any(a => a.AttributeClass?.Name == "RequiredAttribute");
    }

    /// <summary>
    /// Gets client-side validation rules for a property based on its Sannr attributes.
    /// </summary>
    private static string GetClientValidationRules(IPropertySymbol property)
    {
        var rules = new List<string>();
        var attributes = property.GetAttributes();

        foreach (var attr in attributes)
        {
            var attrName = attr.AttributeClass?.Name;

            switch (attrName)
            {
                case "RequiredAttribute":
                    rules.Add("required: true");
                    break;

                case "EmailAddressAttribute":
                    rules.Add("email: true");
                    break;

                case "StringLengthAttribute":
                    var maxLength = attr.NamedArguments.FirstOrDefault(k => k.Key == "MaximumLength").Value.Value;
                    var minLength = attr.NamedArguments.FirstOrDefault(k => k.Key == "MinimumLength").Value.Value;
                    if (maxLength != null) rules.Add($"maxLength: {maxLength}");
                    if (minLength != null) rules.Add($"minLength: {minLength}");
                    break;

                case "RangeAttribute":
                    var min = attr.NamedArguments.FirstOrDefault(k => k.Key == "Minimum").Value.Value;
                    var max = attr.NamedArguments.FirstOrDefault(k => k.Key == "Maximum").Value.Value;
                    if (min != null) rules.Add($"min: {min}");
                    if (max != null) rules.Add($"max: {max}");
                    break;

                case "UrlAttribute":
                    rules.Add("url: true");
                    break;

                case "PhoneAttribute":
                    rules.Add("phone: true");
                    break;

                case "AllowedValuesAttribute":
                    var values = attr.ConstructorArguments.FirstOrDefault().Values;
                    if (values.Length > 0)
                    {
                        var valueStrings = values.Select(v => $"\"{v.Value}\"");
                        rules.Add($"allowedValues: [{string.Join(", ", valueStrings)}]");
                    }
                    break;

                case "CompareAttribute":
                    var otherProp = attr.NamedArguments.FirstOrDefault(k => k.Key == "OtherProperty").Value.Value as string;
                    if (!string.IsNullOrEmpty(otherProp))
                    {
                        rules.Add($"compare: \"{ToCamelCase(otherProp!)}\"");
                    }
                    break;
            }
        }

        return string.Join(", ", rules);
    }

    /// <summary>
    /// Generates the AddSannr extension method for automatic validator registration.
    /// </summary>
    private static void GenerateAddSannrMethod(SourceProductionContext context, ImmutableArray<INamedTypeSymbol> targets)
    {
        if (targets.IsEmpty)
            return;

        var sb = new StringBuilder();
        sb.AppendLine("""
            // <auto-generated/>
            // Sannr Service Registration Generator
            // Generated: {{DateTime.Now:yyyy-MM-dd HH:mm:ss}}
            using Microsoft.Extensions.DependencyInjection;
            using Sannr;

            namespace Sannr.AspNetCore
            {
                public static partial class ServiceCollectionExtensions
                {
                    static partial void RegisterGeneratedValidators(IServiceCollection services);

                    static partial void RegisterGeneratedValidators(IServiceCollection services)
                    {

            """);

        foreach (var classSymbol in targets)
        {
            var className = classSymbol.Name;
            var ns = classSymbol.ContainingNamespace.ToDisplayString();
            var fullName = $"{ns}.{className}";

            sb.AppendLine($$"""
                        // Register validator for {{fullName}}
                        SannrValidatorRegistry.Register<{{fullName}}>({{ns}}.{{className}}Validator.ValidateAsync);

            """);
        }

        sb.AppendLine("""
                    }
                }
            }
            """);

        context.AddSource("SannrServiceRegistration.g.cs", sb.ToString());
    }
}
