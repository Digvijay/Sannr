// ----------------------------------------------------------------------------------
// MIT License
//
// Copyright (c) 2025 Sannr contributors
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// ----------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Sannr.Gen;

/// <summary>
/// Minimal test generator to verify analyzer loading.
/// </summary>
[Generator]
public class TestGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // No-op
    }

    public void Execute(GeneratorExecutionContext context)
    {
        context.AddSource("TestGenerated.g.cs", "// Test generated code");
    }
}

/// <summary>
/// Source generator for Sannr validators. Generates validation logic for attributed classes.
/// </summary>
[Generator]
public class SannrGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Initializes the generator and registers the validator generation pipeline.
    /// </summary>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Debug: Verify generator is initialized
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("GeneratorInitDebug.g.cs", "// Generator initialized successfully at " + DateTime.Now);
        });
        // Simple test: Always add a source file to verify generator is running
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource("TestGenerator.g.cs", "// Test: Generator is working!"));

        // Enhanced incremental validator generation pipeline
        var validatorProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (s, _) => IsValidationTarget(s),
                transform: (ctx, _) => GetValidationTarget(ctx))
            .Where(m => m != null)
            .Collect()
            .Select((targets, _) => targets);

        // Fluent validation configuration pipeline
        var fluentValidatorProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (s, _) => IsFluentValidatorConfig(s),
                transform: (ctx, _) => GetFluentValidatorConfig(ctx))
            .Where(m => m != null)
            .Collect()
            .Select((configs, _) => ProcessFluentValidatorConfigs(configs!));

        // Debug: Always generate a test file to verify fluent pipeline runs
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("FluentDebug.g.cs", "// Fluent generator is running!");
        });

        context.RegisterSourceOutput(validatorProvider, GenerateValidators!);
        context.RegisterSourceOutput(fluentValidatorProvider, GenerateFluentValidators!);

        // Client validation properties are now generated as part of validator generation
        // No separate pipeline needed
    }

    /// <summary>
    /// Generates diagnostic helper methods for the source generator.
    /// </summary>
    private static string GenerateDiagnosticHelpers()
    {
        return """
            // <auto-generated/>
            // Sannr Generator Diagnostic Helpers
            using Microsoft.CodeAnalysis;

            namespace Sannr.Gen.Diagnostics
            {
                internal static class DiagnosticDescriptors
                {
                    public static readonly DiagnosticDescriptor InvalidAttributeUsage = new DiagnosticDescriptor(
                        id: "SANN001",
                        title: "Invalid attribute usage",
                        messageFormat: "Attribute '{0}' is not valid on property '{1}'",
                        category: "SannrGenerator",
                        defaultSeverity: DiagnosticSeverity.Error,
                        isEnabledByDefault: true);

                    public static readonly DiagnosticDescriptor UnsupportedAttribute = new DiagnosticDescriptor(
                        id: "SANN002",
                        title: "Unsupported attribute",
                        messageFormat: "Attribute '{0}' is not supported by Sannr generator",
                        category: "SannrGenerator",
                        defaultSeverity: DiagnosticSeverity.Warning,
                        isEnabledByDefault: true);

                    public static readonly DiagnosticDescriptor RegexCompilationError = new DiagnosticDescriptor(
                        id: "SANN003",
                        title: "Regex compilation error",
                        messageFormat: "Failed to compile regex pattern '{0}': {1}",
                        category: "SannrGenerator",
                        defaultSeverity: DiagnosticSeverity.Error,
                        isEnabledByDefault: true);
                }
            }
            """;
    }

    /// <summary>
    /// Determines if a syntax node is a potential validation target.
    /// </summary>
    private static bool IsValidationTarget(SyntaxNode node)
    {
        if (node is ClassDeclarationSyntax classDecl)
        {
            // Check if it has class-level attributes
            if (classDecl.AttributeLists.Any())
                return true;

            // Check if any properties have validation attributes
            var hasPropertyValidation = classDecl.Members
                .OfType<PropertyDeclarationSyntax>()
                .Any(prop => prop.AttributeLists
                    .SelectMany(al => al.Attributes)
                    .Any(attr =>
                    {
                        var attrName = attr.Name.ToString();
                        return attrName.Contains("Required") ||
                               attrName.Contains("StringLength") ||
                               attrName.Contains("Range") ||
                               attrName.Contains("EmailAddress") ||
                               attrName.Contains("CreditCard") ||
                               attrName.Contains("Url") ||
                               attrName.Contains("Phone") ||
                               attrName.Contains("FileExtensions") ||
                               attrName.Contains("CustomValidator") ||
                               attrName.Contains("RequiredIf") ||
                               attrName.Contains("Sanitize");
                    }));

            if (hasPropertyValidation)
                return true;

            // Check if it inherits from ValidatorConfig
            var hasValidatorConfigBase = classDecl.BaseList?.Types
                .Any(t => t.Type is GenericNameSyntax generic &&
                         generic.Identifier.Text == "ValidatorConfig") == true;

            return hasValidatorConfigBase;
        }

        return false;
    }

    /// <summary>
    /// Determines if a syntax node is a potential client validation target.
    /// </summary>
    private static bool IsClientValidationTarget(SyntaxNode node)
    {
        if (node is ClassDeclarationSyntax classDecl)
        {
            // Check if it has the GenerateClientValidators attribute
            return classDecl.AttributeLists.Any();
        }
        return false;
    }

    /// <summary>
    /// Gets validation target information from syntax context.
    /// </summary>
    private static INamedTypeSymbol? GetValidationTarget(GeneratorSyntaxContext context)
    {
        if (context.Node is ClassDeclarationSyntax classDecl)
        {
            var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
            if (classSymbol != null)
            {
                // Check for regular validation attributes
                if (HasValidationAttributes(classSymbol))
                    return classSymbol;

                // Fluent validators are handled by the separate pipeline
            }
        }
        return null;
    }
    private static void GenerateValidators(SourceProductionContext context, ImmutableArray<INamedTypeSymbol> targets)
    {
        var processedClasses = new HashSet<string>(StringComparer.Ordinal);

        // DEBUG: Output all discovered targets
        var debugSb = new StringBuilder();
        debugSb.AppendLine("// DEBUG: Discovered validation targets:");
        foreach (var t in targets)
        {
            debugSb.AppendLine($"// - {t.ContainingNamespace}.{t.Name}");
        }
        context.AddSource("ValidationTargetsDebug.g.cs", debugSb.ToString());

        foreach (var classSymbol in targets)
        {
            var classKey = $"{classSymbol.ContainingNamespace}.{classSymbol.Name}";
            if (!processedClasses.Add(classKey))
                continue; // Skip duplicate

            // Regular attribute-based validation
            GenerateValidator(context, classSymbol);
        }

        // Generate OpenAPI schema filter for AOT-compatible schema generation
        GenerateOpenApiFilter(context, targets);

        // Generate AddSannr extension method for automatic validator registration
        GenerateAddSannrMethod(context, targets);
    }

    /// <summary>
    /// Gets client validation target information from syntax context.
    /// </summary>
    private static INamedTypeSymbol? GetClientValidationTarget(GeneratorSyntaxContext context)
    {
        if (context.Node is ClassDeclarationSyntax classDecl)
        {
            var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
            if (classSymbol != null)
            {
                var hasAttribute = classSymbol.GetAttributes()
                    .Any(a => a.AttributeClass?.Name == "GenerateClientValidatorsAttribute");
                if (hasAttribute)
                {
                    return classSymbol;
                }
            }
        }
        return null;
    }

    /// <summary>
    /// Processes client validation targets and returns distinct class symbols.
    /// </summary>
    private static ImmutableArray<INamedTypeSymbol> ProcessClientValidationTargets(ImmutableArray<INamedTypeSymbol> targets)
    {
        return targets.Distinct<INamedTypeSymbol>(SymbolEqualityComparer.Default).ToImmutableArray();
    }

    /// <summary>
    /// Generates advanced client-side validators.
    /// </summary>
    private static void GenerateAdvancedClientValidators(
        SourceProductionContext context,
        ImmutableArray<INamedTypeSymbol> targets)
    {
        foreach (var classSymbol in targets)
        {
            GenerateClientValidators(context, classSymbol);
        }
    }

    /// <summary>
    /// Checks if a class symbol has validation attributes on its properties.
    /// </summary>
    private static bool HasValidationAttributes(INamedTypeSymbol classSymbol)
    {
        return classSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Any(prop => prop.GetAttributes().Any(attr =>
                attr.AttributeClass?.Name.EndsWith("Attribute", System.StringComparison.Ordinal) == true &&
                (attr.AttributeClass.Name.Contains("Required", System.StringComparison.Ordinal) ||
                 attr.AttributeClass.Name.Contains("StringLength", System.StringComparison.Ordinal) ||
                 attr.AttributeClass.Name.Contains("Range", System.StringComparison.Ordinal) ||
                 attr.AttributeClass.Name.Contains("EmailAddress", System.StringComparison.Ordinal) ||
                 attr.AttributeClass.Name.Contains("CreditCard", System.StringComparison.Ordinal) ||
                 attr.AttributeClass.Name.Contains("Url", System.StringComparison.Ordinal) ||
                 attr.AttributeClass.Name.Contains("Phone", System.StringComparison.Ordinal) ||
                 attr.AttributeClass.Name.Contains("FileExtensions", System.StringComparison.Ordinal) ||
                 attr.AttributeClass.Name.Contains("CustomValidator", System.StringComparison.Ordinal) ||
                 attr.AttributeClass.Name.Contains("RequiredIf", System.StringComparison.Ordinal) ||
                 attr.AttributeClass.Name.Contains("Sanitize", System.StringComparison.Ordinal))));
    }

    /// <summary>
    /// Gets the semantic symbol for a class marked with GenerateClientValidatorsAttribute.
    /// </summary>
    private static INamedTypeSymbol? GetClientValidationClassSemantic(GeneratorSyntaxContext context)
    {
        if (context.Node is ClassDeclarationSyntax classDecl)
        {
            var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
            if (classSymbol != null)
            {
                var hasAttribute = classSymbol.GetAttributes()
                    .Any(a => a.AttributeClass?.Name == "GenerateClientValidatorsAttribute");
                if (hasAttribute)
                {
                    return classSymbol;
                }
            }
        }
        return null;
    }

    /// <summary>
    /// Gets the semantic symbol for a class containing a property with attributes.
    /// </summary>
    private static INamedTypeSymbol? GetClassSemantic(GeneratorSyntaxContext context)
    {
        if (context.Node is PropertyDeclarationSyntax prop &&
            prop.Parent is ClassDeclarationSyntax classDecl)
        {
            return context.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
        }
        return null;
    }

    /// <summary>
    /// Formats an error message for a validation attribute.
    /// </summary>
    private static string GetFormattedError(AttributeData attr, string defaultFormat, string nameVar, params string[] args)
    {
        string formatExpr = $"\"{defaultFormat}\"";
        var resType = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "ErrorMessageResourceType").Value.Value as INamedTypeSymbol;
        var resName = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "ErrorMessageResourceName").Value.Value as string;
        var explicitMsg = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "ErrorMessage").Value.Value as string;

        if (resType != null && !string.IsNullOrEmpty(resName))
            formatExpr = $"{resType.ToDisplayString()}.{resName}";
        else if (!string.IsNullOrEmpty(explicitMsg))
            formatExpr = $"\"{explicitMsg}\"";

        var sbArgs = new StringBuilder();
        sbArgs.Append(nameVar);
        foreach (var arg in args) sbArgs.Append(", " + arg);

        return $"string.Format({formatExpr}, {sbArgs.ToString()})";
    }

    /// <summary>
    /// Gets the severity value for a validation attribute.
    /// </summary>
    private static string GetSeverity(AttributeData attr)
    {
        var arg = attr.NamedArguments.FirstOrDefault(k => k.Key == "Severity");
        if (arg.Value.Value != null) return $"Severity.{(int)arg.Value.Value}";
        return "Severity.Error";
    }

    /// <summary>
    /// Generates the validator source code for a class symbol.
    /// </summary>
    private static void GenerateValidator(SourceProductionContext spc, INamedTypeSymbol classSymbol)
    {
        var className = classSymbol.Name;
        var ns = classSymbol.ContainingNamespace.ToDisplayString();
        var sb = new StringBuilder();

        sb.AppendLine($$"""
            // <auto-generated/>
            // Advanced Sannr Validator Generator v2.0
            // Generated: {{DateTime.Now:yyyy-MM-dd HH:mm:ss}}
            using System;
            using System.Threading.Tasks;
            using System.Text.RegularExpressions;
            using System.Runtime.CompilerServices;
            using Sannr;
            using Sannr.Core; // Integrate with core metrics for observability

            namespace {{ns}}
            {
                internal static class {{className}}Validator
                {
                    // Pre-compiled regex patterns for optimal performance
                    private static readonly Regex _emailRegex = new Regex(@"^[^@\s]+@[^@\s]+\.[^@\s]+$", RegexOptions.Compiled | RegexOptions.CultureInvariant);
                    private static readonly Regex _creditCardRegex = new Regex(@"^[\d\- ]{13,19}$", RegexOptions.Compiled | RegexOptions.CultureInvariant);
                    private static readonly Regex _urlRegex = new Regex(@"^https?://", RegexOptions.Compiled | RegexOptions.CultureInvariant);
                    private static readonly Regex _phoneRegex = new Regex(@"^[\d\s\-\+\(\)]+$", RegexOptions.Compiled | RegexOptions.CultureInvariant);

                    public static async Task<ValidationResult> ValidateAsync(SannrValidationContext context)
                    {
                        var model = ({{className}})context.ObjectInstance;
                        var result = new ValidationResult();
                        var activeGroup = context.ActiveGroup;
                        Observability.ValidationEvents.Add(1); // Track validation events for observability
                        await Task.CompletedTask; // Suppress CS1998 for synchronous paths
            """);

        foreach (var member in classSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            var attributes = member.GetAttributes();
            var prop = member.Name;

            var sanAttr = attributes.FirstOrDefault(a => a.AttributeClass?.Name == "SanitizeAttribute");
            if (sanAttr != null)
            {
                bool trim = (bool)(sanAttr.NamedArguments.FirstOrDefault(k => k.Key == "Trim").Value.Value ?? false);
                bool upper = (bool)(sanAttr.NamedArguments.FirstOrDefault(k => k.Key == "ToUpper").Value.Value ?? false);
                bool lower = (bool)(sanAttr.NamedArguments.FirstOrDefault(k => k.Key == "ToLower").Value.Value ?? false);

                if (trim) sb.AppendLine($$"""if (model.{{prop}} != null) model.{{prop}} = model.{{prop}}.Trim();""");
                if (upper) sb.AppendLine($$"""if (model.{{prop}} != null) model.{{prop}} = model.{{prop}}.ToUpper();""");
                if (lower) sb.AppendLine($$"""if (model.{{prop}} != null) model.{{prop}} = model.{{prop}}.ToLower();""");
            }

            var displayAttr = attributes.FirstOrDefault(a => a.AttributeClass?.Name == "DisplayAttribute");
            var explicitName = displayAttr?.NamedArguments.FirstOrDefault(k => k.Key == "Name").Value.Value?.ToString();
            string nameVar = explicitName != null ? $"\"{explicitName}\"" : $"\"{prop}\"";

            foreach (var attr in attributes)
            {
                var attrName = attr.AttributeClass?.Name;
                var severity = GetSeverity(attr);
                var groupArg = attr.NamedArguments.FirstOrDefault(k => k.Key == "Group").Value.Value as string;
                if (groupArg != null) sb.AppendLine($$"""if (activeGroup == "{{groupArg}}") {""");

                if (attrName == "RequiredAttribute")
                {
                    var msg = GetFormattedError(attr, "{0} is required.", nameVar);
                    var propType = member.Type;
                    bool isValueType = propType.IsValueType;
                    bool isString = propType.SpecialType == SpecialType.System_String;

                    if (isValueType)
                    {
                        // For value types, Required always passes since they can't be null
                        // But we could add a check for default values if needed
                    }
                    else if (isString)
                    {
                        // For strings, check for null or empty
                        sb.AppendLine($$"""if (model.{{prop}} is null || (model.{{prop}} is string s_{{prop}} && string.IsNullOrWhiteSpace(s_{{prop}}))) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                    }
                    else
                    {
                        // For other reference types (collections, custom objects), just check for null
                        sb.AppendLine($$"""if (model.{{prop}} is null) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                    }
                }
                else if (attrName == "StringLengthAttribute")
                {
                    int max = (int)(attr.ConstructorArguments[0].Value ?? 0);
                    int min = 0;
                    var minArg = attr.NamedArguments.FirstOrDefault(k => k.Key == "MinimumLength");
                    if (minArg.Value.Value != null) min = (int)minArg.Value.Value;
                    var msg = GetFormattedError(attr, "The field {0} must be a string with a maximum length of {1}.", nameVar, max.ToString());
                    if (min > 0)
                    {
                        sb.AppendLine($$"""if (model.{{prop}} is string str_{{prop}} && (str_{{prop}}.AsSpan().Length < {{min}} || str_{{prop}}.AsSpan().Length > {{max}})) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                    }
                    else
                    {
                        sb.AppendLine($$"""if (model.{{prop}} is string str_{{prop}} && str_{{prop}}.AsSpan().Length > {{max}}) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                    }
                }
                else if (attrName == "RangeAttribute" && attr.ConstructorArguments.Length >= 2)
                {
                    var min = attr.ConstructorArguments[0].Value;
                    var max = attr.ConstructorArguments[1].Value;
                    var msg = GetFormattedError(attr, "The field {0} must be between {1} and {2}.", nameVar, min?.ToString() ?? "0", max?.ToString() ?? "0");

                    var isDecimal = member.Type.SpecialType == SpecialType.System_Decimal ||
                                   (member.Type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T &&
                                    (member.Type as INamedTypeSymbol)?.TypeArguments.FirstOrDefault()?.SpecialType == SpecialType.System_Decimal);
                    var cast = isDecimal ? "(decimal)" : "";

                    sb.AppendLine($$"""if (model.{{prop}} < {{cast}}{{min}} || model.{{prop}} > {{cast}}{{max}}) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                }
                else if (attrName == "EmailAddressAttribute")
                {
                    var msg = GetFormattedError(attr, "The {0} field is not a valid e-mail address.", nameVar);
                    sb.AppendLine($$"""if (model.{{prop}} != null && !_emailRegex.IsMatch(model.{{prop}}.ToString())) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                }
                else if (attrName == "CreditCardAttribute")
                {
                    var msg = GetFormattedError(attr, "The {0} field is not a valid credit card number.", nameVar);
                    sb.AppendLine($$"""if (model.{{prop}} != null && !_creditCardRegex.IsMatch(model.{{prop}}.ToString())) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                }
                else if (attrName == "UrlAttribute")
                {
                    var msg = GetFormattedError(attr, "The {0} field is not a valid URL.", nameVar);
                    sb.AppendLine($$"""if (model.{{prop}} != null && !_urlRegex.IsMatch(model.{{prop}}.ToString())) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                }
                else if (attrName == "PhoneAttribute")
                {
                    var msg = GetFormattedError(attr, "The {0} field is not a valid phone number.", nameVar);
                    sb.AppendLine($$"""if (model.{{prop}} != null && !_phoneRegex.IsMatch(model.{{prop}}.ToString())) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                }
                else if (attrName == "FileExtensionsAttribute")
                {
                    var extensions = attr.NamedArguments.FirstOrDefault(k => k.Key == "Extensions").Value.Value as string ?? "png,jpg,jpeg,gif";
                    var extArray = extensions.Split(',').Select(e => e.Trim().ToLower(System.Globalization.CultureInfo.InvariantCulture)).Where(e => !string.IsNullOrEmpty(e)).ToArray();
                    var extList = string.Join(", ", extArray.Select(e => "." + e));
                    // Build all parts as separate strings
                    var msgText = "The {0} field must have one of the following extensions: " + extList + ".";
                    var msgPart = "string.Format(\"" + msgText + "\", " + nameVar + ")";
                    var condParts = new System.Collections.Generic.List<string>();
                    foreach (var ext in extArray)
                    {
                        condParts.Add("!model." + prop + ".ToString().EndsWith(\"." + ext + "\", System.StringComparison.OrdinalIgnoreCase)");
                    }
                    var conditionStr = string.Join(" && ", condParts);
                    sb.AppendLine("if (model." + prop + " != null && (" + conditionStr + ")) result.Add(\"" + prop + "\", " + msgPart + ", " + severity + ");");
                }
                else if (attrName == "RequiredIfAttribute")
                {
                    var other = attr.ConstructorArguments[0].Value?.ToString();
                    var val = attr.ConstructorArguments[1].Value;
                    string valStr;
                    if (val is string s)
                    {
                        valStr = $"\"{s}\"";
                    }
                    else if (val == null)
                    {
                        valStr = "null";
                    }
                    else
                    {
                        valStr = val.ToString();
                        if (val is bool) valStr = valStr.ToLower(System.Globalization.CultureInfo.InvariantCulture);
                    }
                    var msg = GetFormattedError(attr, "{0} is required.", nameVar);

                    // Check if the property type is a string
                    var propType = member.Type;
                    bool isStringType = propType.SpecialType == SpecialType.System_String;

                    if (isStringType)
                    {
                        sb.AppendLine($$"""if (object.Equals(model.{{other}}, {{valStr}}) && (model.{{prop}} is null || string.IsNullOrWhiteSpace(model.{{prop}}))) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                    }
                    else
                    {
                        // For non-string types, just check if the condition is met
                        sb.AppendLine($$"""if (object.Equals(model.{{other}}, {{valStr}}) && model.{{prop}} is null) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                    }
                }
                else if (attrName == "FutureDateAttribute")
                {
                    var msg = GetFormattedError(attr, "The {0} field must be a future date.", nameVar);
                    sb.AppendLine($$"""if (model.{{prop}} != default && model.{{prop}} <= DateTime.Now) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                }
                else if (attrName == "AllowedValuesAttribute" && attr.ConstructorArguments.Length > 0)
                {
                    var values = attr.ConstructorArguments[0].Values.Select(v => $"\"{v.Value}\"").ToArray();
                    var valuesList = string.Join(", ", values);
                    var valuesDisplay = string.Join(", ", attr.ConstructorArguments[0].Values.Select(v => v.Value));
                    var msg = GetFormattedError(attr, "The {0} field must be one of the following values: {1}.", nameVar, $"\"{valuesDisplay}\"");
                    sb.AppendLine($$"""if (model.{{prop}} != null && !new[] { {{valuesList}} }.Contains(model.{{prop}}.ToString())) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                }
                else if (attrName == "ConditionalRangeAttribute")
                {
                    var other = attr.ConstructorArguments[0].Value?.ToString();
                    var targetVal = attr.ConstructorArguments[1].Value;
                    var min = attr.ConstructorArguments[2].Value;
                    var max = attr.ConstructorArguments[3].Value;

                    string targetValStr = targetVal is string ? $"\"{targetVal}\"" : (targetVal?.ToString()?.ToLower(System.Globalization.CultureInfo.InvariantCulture) ?? "null");
                    var targetValDisplay = targetVal?.ToString() ?? "null";
                    var msg = GetFormattedError(attr, "The field {0} must be between {1} and {2} when {3} is {4}.", nameVar, min?.ToString() ?? "0", max?.ToString() ?? "0", $"\"{other}\"", $"\"{targetValDisplay}\"");

                    var isDecimal = member.Type.SpecialType == SpecialType.System_Decimal ||
                                   (member.Type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T &&
                                    (member.Type as INamedTypeSymbol)?.TypeArguments.FirstOrDefault()?.SpecialType == SpecialType.System_Decimal);
                    var cast = isDecimal ? "(decimal)" : "";

                    sb.AppendLine($$"""if (object.Equals(model.{{other}}, {{targetValStr}}) && (model.{{prop}} < {{cast}}{{min}} || model.{{prop}} > {{cast}}{{max}})) result.Add("{{prop}}", {{msg}}, {{severity}});""");
                }
                else if (attrName == "CustomValidatorAttribute")
                {
                    var type = attr.ConstructorArguments[0].Value as INamedTypeSymbol;
                    var method = attr.ConstructorArguments[1].Value?.ToString() ?? "Check";
                    var isAsync = (bool)(attr.NamedArguments.FirstOrDefault(k => k.Key == "IsAsync").Value.Value ?? false);
                    if (type != null)
                    {
                        string call = isAsync
                            ? $"await {type.ToDisplayString()}.{method}(model.{prop}, context.ServiceProvider)"
                            : $"{type.ToDisplayString()}.{method}(model.{prop}, context.ServiceProvider)";
                        sb.AppendLine($$"""var customRes_{{prop}} = {{call}}; result.Merge(customRes_{{prop}}, "{{prop}}");""");
                    }
                }
                if (groupArg != null) sb.AppendLine("}");
            }
        }

        // Check if the class implements IValidatableObject
        var iValidatableObjectInterface = classSymbol.AllInterfaces.FirstOrDefault(i => i.Name == "IValidatableObject" && i.ContainingNamespace.Name == "Sannr");
        if (iValidatableObjectInterface != null)
        {
            sb.AppendLine($$"""
                        // Call IValidatableObject.Validate if implemented
                        if (model is Sannr.IValidatableObject validatable)
                        {
                            var modelResults = validatable.Validate(context);
                            foreach (var modelResult in modelResults)
                            {
                                result.Add(modelResult.MemberName ?? "", modelResult.Message, modelResult.Severity);
                            }
                        }
            """);
        }

        sb.AppendLine($$"""
                        return result;
                    }
                }
                internal static class {{className}}SannrLoader
                {
                    [ModuleInitializer]
                    internal static void Load()
                    {
                        SannrValidatorRegistry.Register(typeof({{className}}), async (ctx) => await {{className}}Validator.ValidateAsync(ctx));
                    }
                }
            }
            """);
        spc.AddSource($"{ns}.{className}.SannrValidator.g.cs", sb.ToString());

        // Generate client validation properties for this class
        GenerateClientValidationProperties(spc, classSymbol);
    }

    /// <summary>
    /// Generates client validation properties (JSON, TypeScript, JavaScript) for a validated class.
    /// </summary>
    private static void GenerateClientValidationProperties(SourceProductionContext spc, INamedTypeSymbol classSymbol)
    {
        var className = classSymbol.Name;
        var ns = classSymbol.ContainingNamespace.ToDisplayString();

        // Build JSON validation rules
        var jsonRules = new List<string>();
        var tsProperties = new List<string>();
        var tsValidators = new List<string>();
        var jsValidators = new List<string>();

        foreach (var member in classSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            var propName = ToCamelCase(member.Name);
            var tsType = GetTypeScriptType(member.Type);
            var isOptional = !IsRequiredProperty(member);

            // TypeScript interface property
            tsProperties.Add($"  {propName}{(isOptional ? "?" : "")}: {tsType};");

            // Get validation rules
            var rules = new List<string>();
            foreach (var attr in member.GetAttributes())
            {
                var attrName = attr.AttributeClass?.Name;
                switch (attrName)
                {
                    case "RequiredAttribute":
                        rules.Add("required: true");
                        break;
                    case "EmailAddressAttribute":
                        rules.Add("email: true");
                        break;
                    case "StringLengthAttribute" when attr.ConstructorArguments.Length > 0:
                        var max = (int)(attr.ConstructorArguments[0].Value ?? 0);
                        var minArg = attr.NamedArguments.FirstOrDefault(k => k.Key == "MinimumLength");
                        var min = minArg.Value.Value != null ? (int)minArg.Value.Value : 0;
                        if (max > 0) rules.Add($"maxLength: {max}");
                        if (min > 0) rules.Add($"minLength: {min}");
                        break;
                    case "RangeAttribute" when attr.ConstructorArguments.Length >= 2:
                        var minVal = attr.ConstructorArguments[0].Value;
                        var maxVal = attr.ConstructorArguments[1].Value;
                        if (minVal != null) rules.Add($"min: {minVal}");
                        if (maxVal != null) rules.Add($"max: {maxVal}");
                        break;
                    case "UrlAttribute":
                        rules.Add("url: true");
                        break;
                    case "PhoneAttribute":
                        rules.Add("phone: true");
                        break;
                    case "CreditCardAttribute":
                        rules.Add("creditCard: true");
                        break;
                    case "RequiredIfAttribute" when attr.ConstructorArguments.Length >= 2:
                        var otherProp = attr.ConstructorArguments[0].Value?.ToString();
                        var targetValue = attr.ConstructorArguments[1].Value;
                        var targetValueJs = targetValue is string ? $"'{targetValue}'" : (targetValue?.ToString()?.ToLower(System.Globalization.CultureInfo.InvariantCulture) ?? "null");
                        rules.Add($"requiredIf: {{ otherProperty: '{ToCamelCase(otherProp ?? "")}', targetValue: {targetValueJs} }}");
                        break;
                    case "AllowedValuesAttribute" when attr.ConstructorArguments.Length > 0:
                        var vals = attr.ConstructorArguments[0].Values.Select(v => $"'{v.Value}'").ToArray();
                        rules.Add($"allowedValues: [{string.Join(", ", vals)}]");
                        break;
                }
            }

            if (rules.Count > 0)
            {
                var rulesStr = string.Join(", ", rules);
                jsonRules.Add($"\\\"{propName}\\\": {{ {rulesStr} }}");
                tsValidators.Add($"  {propName}: {{ {rulesStr} }}");
                jsValidators.Add($"  {propName}: {{ {rulesStr} }}");
            }
        }

        // Generate the C# file with static properties
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine($"// Sannr Client Validation for {className}");
        sb.AppendLine();
        sb.AppendLine($"namespace {ns}");
        sb.AppendLine("{");
        sb.AppendLine($"#pragma warning disable CS0108 // Member hides inherited member; missing new keyword");
        sb.AppendLine($"    public partial class {className}");
        sb.AppendLine("    {");

        // JSON validation rules
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Gets the client-side validation rules as JSON.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        public static string ValidationRulesJson => \"{{{string.Join(",", jsonRules)}}}\";");

        // TypeScript validation rules
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Gets the client-side validation rules as TypeScript code.");
        sb.AppendLine("        /// </summary>");
        var tsInterface = string.Join("\\n", tsProperties);
        var tsVals = string.Join(",\\n", tsValidators);
        sb.AppendLine($"        public static string ValidationRulesTypeScript => \"export interface {className} {{\\n{tsInterface}\\n}}\\n\\nexport const {ToCamelCase(className)}Validators = {{\\n{tsVals}\\n}};\";");

        // JavaScript validation rules
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Gets the client-side validation rules as JavaScript code.");
        sb.AppendLine("        /// </summary>");
        var jsVals = string.Join(",\\n", jsValidators);
        sb.AppendLine($"        public static string ValidationRulesJavaScript => \"const {ToCamelCase(className)}Validators = {{\\n{jsVals}\\n}};\";");

        sb.AppendLine("    }");
        sb.AppendLine("}");

        spc.AddSource($"{ns}.{className}.ClientValidation.g.cs", sb.ToString());
    }

    /// <summary>
    /// Generates an AOT-compatible OpenAPI schema filter using compile-time generation.
    /// </summary>
    private static void GenerateOpenApiFilter(SourceProductionContext context, ImmutableArray<INamedTypeSymbol> targets)
    {
        // Don't generate OpenAPI filter if there are no targets
        if (!targets.Any())
            return;

        // Check if Swashbuckle is available by looking for the ISchemaFilter interface
        // This prevents generating the filter for console apps or projects without Swashbuckle
        var compilation = targets[0].ContainingAssembly.GetTypeByMetadataName("Swashbuckle.AspNetCore.SwaggerGen.ISchemaFilter");
        var hasSwashbuckle = compilation != null;

        if (!hasSwashbuckle)
        {
            // Try checking references
            var referencedAssemblies = targets[0].ContainingAssembly.Modules.FirstOrDefault()?.ReferencedAssemblies;
            hasSwashbuckle = referencedAssemblies?.Any(a => a.Name.Contains("Swashbuckle")) ?? false;
        }

        // Don't generate if Swashbuckle isn't referenced
        if (!hasSwashbuckle)
            return;

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// Sannr OpenAPI Schema Filter Generator");
        sb.AppendLine("// Generated: " + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"));
        sb.AppendLine("using Microsoft.OpenApi.Models;");
        sb.AppendLine("using Swashbuckle.AspNetCore.SwaggerGen;");
        sb.AppendLine("using System;");
        sb.AppendLine("");
        sb.AppendLine("namespace Sannr.OpenApi");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// AOT-compatible OpenAPI schema filter generated at compile-time.");
        sb.AppendLine("    /// Applies validation rules to OpenAPI schemas without runtime reflection.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public class SannrGeneratedSchemaFilter : ISchemaFilter");
        sb.AppendLine("    {");
        sb.AppendLine("        public void Apply(OpenApiSchema schema, SchemaFilterContext context)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (schema.Properties == null || context.Type == null)");
        sb.AppendLine("                return;");
        sb.AppendLine("");
        sb.AppendLine("            var typeName = context.Type.FullName;");
        sb.AppendLine("            switch (typeName)");
        sb.AppendLine("            {");

        foreach (var classSymbol in targets)
        {
            var className = classSymbol.Name;
            var ns = classSymbol.ContainingNamespace.ToDisplayString();
            var fullName = $"{ns}.{className}";

            sb.AppendLine($"                case \"{fullName}\":");
            sb.AppendLine($"                    Apply{className}Schema(schema);");
            sb.AppendLine("                    break;");
        }

        sb.AppendLine("            }");
        sb.AppendLine("        }");

        // Generate the Apply methods for each class
        foreach (var classSymbol in targets)
        {
            var className = classSymbol.Name;
            sb.AppendLine($"");
            sb.AppendLine($"        private static void Apply{className}Schema(OpenApiSchema schema)");
            sb.AppendLine("        {");
            sb.AppendLine("            OpenApiSchema propertySchema;");

            foreach (var member in classSymbol.GetMembers().OfType<IPropertySymbol>())
            {
                var attributes = member.GetAttributes();
                var prop = member.Name;

                sb.AppendLine($"            if (schema.Properties.TryGetValue(\"{prop}\", out propertySchema))");
                sb.AppendLine("            {");

                foreach (var attr in attributes)
                {
                    var attrName = attr.AttributeClass?.Name;
                    if (attrName == "RequiredAttribute")
                    {
                        // Required is handled at object level
                    }
                    else if (attrName == "StringLengthAttribute")
                    {
                        int max = (int)(attr.ConstructorArguments[0].Value ?? 0);
                        int min = 0;
                        var minArg = attr.NamedArguments.FirstOrDefault(k => k.Key == "MinimumLength");
                        if (minArg.Value.Value != null) min = (int)minArg.Value.Value;
                        if (max > 0) sb.AppendLine($"                propertySchema.MaxLength = {max};");
                        if (min > 0) sb.AppendLine($"                propertySchema.MinLength = {min};");
                    }
                    else if (attrName == "RangeAttribute")
                    {
                        var min = attr.ConstructorArguments[0].Value;
                        var max = attr.ConstructorArguments[1].Value;
                        if (min != null) sb.AppendLine($"                propertySchema.Minimum = (decimal){min};");
                        if (max != null) sb.AppendLine($"                propertySchema.Maximum = (decimal){max};");
                    }
                    else if (attrName == "EmailAddressAttribute")
                    {
                        sb.AppendLine("                propertySchema.Format = \"email\";");
                    }
                    else if (attrName == "UrlAttribute")
                    {
                        sb.AppendLine("                propertySchema.Format = \"uri\";");
                    }
                    else if (attrName == "FileExtensionsAttribute")
                    {
                        sb.AppendLine("                propertySchema.Format = \"file\";");
                    }
                    else if (attrName == "PhoneAttribute")
                    {
                        // No standard format
                    }
                    else if (attrName == "CreditCardAttribute")
                    {
                        // No standard format
                    }
                }

                sb.AppendLine("            }");
            }

            sb.AppendLine("        }");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource("SannrGeneratedSchemaFilter.g.cs", sb.ToString());
    }

    /// <summary>
    /// Generates client-side validation code for a class marked with GenerateClientValidatorsAttribute.
    /// </summary>
    private static void GenerateClientValidators(SourceProductionContext spc, INamedTypeSymbol classSymbol)
    {
        var className = classSymbol.Name;
        var ns = classSymbol.ContainingNamespace.ToDisplayString();
        var attribute = classSymbol.GetAttributes()
            .First(a => a.AttributeClass?.Name == "GenerateClientValidatorsAttribute");

        var language = (int)(attribute.NamedArguments.FirstOrDefault(k => k.Key == "Language").Value.Value ?? 0);
        var outputDir = attribute.NamedArguments.FirstOrDefault(k => k.Key == "OutputDirectory").Value.Value as string;
        var generateFunctions = (bool)(attribute.NamedArguments.FirstOrDefault(k => k.Key == "GenerateValidationFunctions").Value.Value ?? true);
        var customNamespace = attribute.NamedArguments.FirstOrDefault(k => k.Key == "Namespace").Value.Value as string;

        var clientNamespace = customNamespace ?? ns.ToLower(System.Globalization.CultureInfo.InvariantCulture).Replace(".", "_");

        var sb = new StringBuilder();

        // Generate TypeScript interface
        sb.AppendLine($"// <auto-generated/>");
        sb.AppendLine($"#pragma warning disable CS0108 // Member hides inherited member; missing new keyword");
        sb.AppendLine($"// Generated from {ns}.{className}");
        sb.AppendLine();
        sb.AppendLine($"export interface {className} {{");

        // Generate interface properties
        foreach (var member in classSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            var propName = ToCamelCase(member.Name);
            var propType = GetTypeScriptType(member.Type);
            var isOptional = !IsRequiredProperty(member);

            sb.AppendLine($"    {propName}{(isOptional ? "?" : "")}: {propType};");
        }

        sb.AppendLine("}");
        sb.AppendLine();

        // Generate validation rules object
        sb.AppendLine($"export const {ToCamelCase(className)}Validators = {{");

        foreach (var member in classSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            var propName = ToCamelCase(member.Name);
            var rules = GetClientValidationRules(member);

            if (!string.IsNullOrEmpty(rules))
            {
                sb.AppendLine($"    {propName}: {{ {rules} }},");
            }
        }

        sb.AppendLine("};");

        // Generate validation functions if requested
        if (generateFunctions)
        {
            sb.AppendLine();
            sb.AppendLine($"export function validate{className}(model: {className}): ValidationResult {{");
            sb.AppendLine("    const errors: string[] = [];");
            sb.AppendLine();
            sb.AppendLine($"    // Validate each property using the rules");
            sb.AppendLine($"    Object.keys({ToCamelCase(className)}Validators).forEach(key => {{");
            sb.AppendLine($"        const rules = {ToCamelCase(className)}Validators[key as keyof typeof {ToCamelCase(className)}Validators];");
            sb.AppendLine("        const value = model[key as keyof typeof model];");
            sb.AppendLine("        const fieldErrors = validateField(value, rules);");
            sb.AppendLine("        if (fieldErrors.length > 0) {");
            sb.AppendLine("            errors.push(...fieldErrors.map(err => `${key}: ${err}`));");
            sb.AppendLine("        }");
            sb.AppendLine("    });");
            sb.AppendLine();
            sb.AppendLine("    return {");
            sb.AppendLine("        isValid: errors.length === 0,");
            sb.AppendLine("        errors");
            sb.AppendLine("    };");
            sb.AppendLine("}");
            sb.AppendLine();
            sb.AppendLine("export interface ValidationResult {");
            sb.AppendLine("    isValid: boolean;");
            sb.AppendLine("    errors: string[];");
            sb.AppendLine("}");
            sb.AppendLine();
            sb.AppendLine("function validateField(value: any, rules: any): string[] {");
            sb.AppendLine("    const errors: string[] = [];");
            sb.AppendLine();
            sb.AppendLine("    if (rules.required && (value === null || value === undefined || value === '')) {");
            sb.AppendLine("        errors.push('This field is required');");
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine("    if (value !== null && value !== undefined && value !== '') {");
            sb.AppendLine(@"        if (rules.email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {");
            sb.AppendLine("            errors.push('Invalid email format');");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        if (rules.minLength !== undefined && value.length < rules.minLength) {");
            sb.AppendLine("            errors.push(`Minimum length is ${rules.minLength}`);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        if (rules.maxLength !== undefined && value.length > rules.maxLength) {");
            sb.AppendLine("            errors.push(`Maximum length is ${rules.maxLength}`);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        if (rules.min !== undefined && value < rules.min) {");
            sb.AppendLine("            errors.push(`Minimum value is ${rules.min}`);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        if (rules.max !== undefined && value > rules.max) {");
            sb.AppendLine("            errors.push(`Maximum value is ${rules.max}`);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        if (rules.pattern && !new RegExp(rules.pattern).test(value)) {");
            sb.AppendLine("            errors.push('Invalid format');");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        if (rules.url && !/^https?:\\/\\/.+/.test(value)) {");
            sb.AppendLine("            errors.push('Invalid URL format');");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        if (rules.allowedValues && !rules.allowedValues.includes(value)) {");
            sb.AppendLine("            errors.push(`Value must be one of: ${rules.allowedValues.join(', ')}`);");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine("    return errors;");
            sb.AppendLine("}");
        }

        // Determine file extension based on language
        var extension = language switch
        {
            0 => ".ts", // TypeScript
            1 => ".js", // JavaScript
            2 => ".json", // JSON
            _ => ".ts"
        };

        var fileName = $"{clientNamespace}.{className}.validators{extension}";
        spc.AddSource(fileName, sb.ToString());
    }

    /// <summary>
    /// Converts a property name to camelCase for JavaScript/TypeScript.
    /// </summary>
    private static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name ?? "";
        return char.ToLower(name[0], System.Globalization.CultureInfo.InvariantCulture) + name.Substring(1);
    }

    /// <summary>
    /// Gets the TypeScript type for a .NET type.
    /// </summary>
    private static string GetTypeScriptType(ITypeSymbol type)
    {
        return type.SpecialType switch
        {
            SpecialType.System_String => "string",
            SpecialType.System_Int32 or SpecialType.System_Int64 or SpecialType.System_Int16 => "number",
            SpecialType.System_Decimal or SpecialType.System_Double or SpecialType.System_Single => "number",
            SpecialType.System_Boolean => "boolean",
            SpecialType.System_DateTime => "string", // ISO date string
            _ => type.Name.ToLower(System.Globalization.CultureInfo.InvariantCulture)
        };
    }

    /// <summary>
    /// Checks if a property is required based on its attributes.
    /// </summary>
    private static bool IsRequiredProperty(IPropertySymbol property)
    {
        return property.GetAttributes().Any(a => a.AttributeClass?.Name == "RequiredAttribute");
    }

    /// <summary>
    /// Gets client-side validation rules for a property based on its Sannr attributes.
    /// </summary>
    private static string GetClientValidationRules(IPropertySymbol property)
    {
        var rules = new List<string>();
        var attributes = property.GetAttributes();

        foreach (var attr in attributes)
        {
            var attrName = attr.AttributeClass?.Name;

            switch (attrName)
            {
                case "RequiredAttribute":
                    rules.Add("required: true");
                    break;

                case "EmailAddressAttribute":
                    rules.Add("email: true");
                    break;

                case "StringLengthAttribute":
                    var maxLength = attr.NamedArguments.FirstOrDefault(k => k.Key == "MaximumLength").Value.Value;
                    var minLength = attr.NamedArguments.FirstOrDefault(k => k.Key == "MinimumLength").Value.Value;
                    if (maxLength != null) rules.Add($"maxLength: {maxLength}");
                    if (minLength != null) rules.Add($"minLength: {minLength}");
                    break;

                case "RangeAttribute":
                    var min = attr.NamedArguments.FirstOrDefault(k => k.Key == "Minimum").Value.Value;
                    var max = attr.NamedArguments.FirstOrDefault(k => k.Key == "Maximum").Value.Value;
                    if (min != null) rules.Add($"min: {min}");
                    if (max != null) rules.Add($"max: {max}");
                    break;

                case "UrlAttribute":
                    rules.Add("url: true");
                    break;

                case "PhoneAttribute":
                    rules.Add("phone: true");
                    break;

                case "AllowedValuesAttribute" when attr.ConstructorArguments.Length > 0:
                    var values = attr.ConstructorArguments.FirstOrDefault().Values;
                    if (values.Length > 0)
                    {
                        var valueStrings = values.Select(v => $"\"{v.Value}\"");
                        rules.Add($"allowedValues: [{string.Join(", ", valueStrings)}]");
                    }
                    break;

                case "CompareAttribute":
                    var otherProp = attr.NamedArguments.FirstOrDefault(k => k.Key == "OtherProperty").Value.Value as string;
                    if (!string.IsNullOrEmpty(otherProp))
                    {
                        rules.Add($"compare: \"{ToCamelCase(otherProp!)}\"");
                    }
                    break;
            }
        }

        return string.Join(", ", rules);
    }

    /// <summary>
    /// Generates the AddSannr extension method for automatic validator registration.
    /// </summary>
    private static void GenerateAddSannrMethod(SourceProductionContext context, ImmutableArray<INamedTypeSymbol> targets)
    {
        if (targets.IsEmpty)
            return;

        var sb = new StringBuilder();
        sb.AppendLine("""
            // <auto-generated/>
            // Sannr Service Registration Generator
            // Generated: {{DateTime.Now:yyyy-MM-dd HH:mm:ss}}
            using Microsoft.Extensions.DependencyInjection;
            using Sannr;

            namespace Sannr.AspNetCore
            {
                public static partial class ServiceCollectionExtensions
                {
                    static partial void RegisterGeneratedValidators(IServiceCollection services);

                    static partial void RegisterGeneratedValidators(IServiceCollection services)
                    {

            """);

        foreach (var classSymbol in targets)
        {
            var className = classSymbol.Name;
            var ns = classSymbol.ContainingNamespace.ToDisplayString();
            var fullName = $"{ns}.{className}";

            sb.AppendLine($$"""
                        // Register validator for {{fullName}}
                        SannrValidatorRegistry.Register<{{fullName}}>({{ns}}.{{className}}Validator.ValidateAsync);

            """);
        }

        sb.AppendLine("""
                    }
                }
            }
            """);

        context.AddSource("SannrServiceRegistration.g.cs", sb.ToString());
    }

    #region Fluent Validation Support

    /// <summary>
    /// Determines if a syntax node is a fluent validator configuration class.
    /// </summary>
    private static bool IsFluentValidatorConfig(SyntaxNode node)
    {
        if (node is ClassDeclarationSyntax classDecl)
        {
            // Check if it inherits from ValidatorConfig<T>
            var hasValidatorConfigBase = classDecl.BaseList?.Types
                .Any(t => t.Type is GenericNameSyntax generic &&
                         generic.Identifier.Text == "ValidatorConfig") == true;

            // Debug: Add source file for any class that inherits from ValidatorConfig
            if (hasValidatorConfigBase)
            {
                // We'll add debug output in the transform method instead
            }

            return hasValidatorConfigBase;
        }
        return false;
    }

    /// <summary>
    /// Gets fluent validator configuration information from syntax context.
    /// </summary>
    private static FluentValidatorConfigInfo? GetFluentValidatorConfig(GeneratorSyntaxContext context)
    {
        if (context.Node is ClassDeclarationSyntax classDecl)
        {
            var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
            if (classSymbol != null && classSymbol.BaseType?.Name == "ValidatorConfig")
            {
                var targetType = classSymbol.BaseType.TypeArguments.FirstOrDefault();
                if (targetType != null)
                {
                    // Find the Configure method
                    var configureMethod = classSymbol.GetMembers()
                        .OfType<IMethodSymbol>()
                        .FirstOrDefault(m => m.Name == "Configure" && m.Parameters.Length == 0);

                    if (configureMethod != null)
                    {
                        // Extract the actual method body from syntax
                        var methodBody = ExtractMethodBody(classDecl, configureMethod);
                        return new FluentValidatorConfigInfo(classSymbol, targetType, methodBody);
                    }
                }
            }
        }
        return null;
    }

    /// <summary>
    /// Extracts the method body from a class declaration syntax.
    /// </summary>
    private static string? ExtractMethodBody(ClassDeclarationSyntax classDecl, IMethodSymbol methodSymbol)
    {
        // Find the Configure method in the syntax tree
        var configureMethod = classDecl.DescendantNodes()
            .OfType<MethodDeclarationSyntax>()
            .FirstOrDefault(m => m.Identifier.Text == "Configure" && m.ParameterList.Parameters.Count == 0);

        if (configureMethod?.Body != null)
        {
            // Extract the method body as text
            return configureMethod.Body.ToString();
        }

        return null;
    }

    /// <summary>
    /// Processes fluent validator configurations.
    /// </summary>
    private static ImmutableArray<FluentValidatorConfigInfo> ProcessFluentValidatorConfigs(
        ImmutableArray<FluentValidatorConfigInfo> configs)
    {
        return configs.Distinct().ToImmutableArray();
    }

    /// <summary>
    /// Generates validators from fluent configurations.
    /// </summary>
    private static void GenerateFluentValidators(SourceProductionContext context,
        ImmutableArray<FluentValidatorConfigInfo> configs)
    {
        context.AddSource("FluentValidatorsDebug.g.cs", $"// DEBUG: GenerateFluentValidators called with {configs.Length} configs");

        foreach (var config in configs)
        {
            GenerateFluentValidator(context, config);
        }
    }

    /// <summary>
    /// Generates a validator from a fluent configuration.
    /// </summary>
    private static void GenerateFluentValidator(SourceProductionContext context,
        FluentValidatorConfigInfo config)
    {
        var className = $"{config.ConfigClass.Name.Replace("Validator", "")}FluentValidator";
        var ns = config.ConfigClass.ContainingNamespace.ToDisplayString();

        // Check if we've already generated this validator
        var validatorKey = $"{ns}.{className}";
        if (_generatedValidators.Contains(validatorKey))
            return;

        _generatedValidators.Add(validatorKey);

        var hintName = $"{config.ConfigClass.Name}.FluentValidator.{Guid.NewGuid()}.g.cs";

        var sb = new StringBuilder();
        var targetTypeName = config.TargetType.ToDisplayString();

        // Parse the fluent configuration to generate validation logic
        var validationCode = GenerateValidationCode(config);

        sb.AppendLine($$"""
            // <auto-generated/>
            // Generated from fluent configuration: {{config.ConfigClass.Name}}

            using System;
            using System.Threading.Tasks;
            using Sannr;

            namespace {{ns}}
            {
                /// <summary>
                /// Auto-generated validator for {{targetTypeName}} based on fluent configuration.
                /// </summary>
                public static class {{className}}
                {
                    /// <summary>
                    /// Validates an instance of {{targetTypeName}}.
                    /// </summary>
                    public static async Task<ValidationResult> ValidateAsync({{targetTypeName}} instance)
                    {
                        var result = new ValidationResult();

            {{validationCode}}

                        return result;
                    }
                }
            }
            """);

        context.AddSource(hintName, sb.ToString());
    }

    private static readonly HashSet<string> _generatedValidators = new();

    /// <summary>
    /// Generates validation code from fluent configuration.
    /// </summary>
    private static string GenerateValidationCode(FluentValidatorConfigInfo config)
    {
        if (string.IsNullOrEmpty(config.MethodBody))
            return "// No validation rules configured";

        // Parse the fluent validation rules from the method body
        return ParseFluentValidationRules(config.MethodBody, config.TargetType);
    }

    /// <summary>
    /// Parses fluent validation rules from the Configure method body.
    /// </summary>
    private static string ParseFluentValidationRules(string methodBody, ITypeSymbol targetType)
    {
        // For debugging: Add the raw method body to the generated code
        var debugSb = new StringBuilder();
        debugSb.AppendLine("// DEBUG: Raw method body:");
        debugSb.AppendLine("// " + methodBody.Replace("\n", "\n// "));
        debugSb.AppendLine();

        // Parse the fluent validation rules from the method body
        var validationCode = ParseFluentValidationFromString(methodBody, targetType);

        debugSb.AppendLine(validationCode);
        return debugSb.ToString();
    }

    /// <summary>
    /// Parses fluent validation rules from method body string (fallback approach).
    /// </summary>
    private static string ParseFluentValidationFromString(string methodBody, ITypeSymbol targetType)
    {
        var sb = new StringBuilder();
        var lines = methodBody.Split('\n', StringSplitOptions.RemoveEmptyEntries)
                              .Select(line => line.Trim())
                              .Where(line => !string.IsNullOrWhiteSpace(line))
                              .ToArray();

        var ruleChains = new Dictionary<string, RuleChainInfo>();

        foreach (var line in lines)
        {
            // Look for RuleFor calls
            if (line.Contains("RuleFor("))
            {
                var propertyMatch = System.Text.RegularExpressions.Regex.Match(line, @"RuleFor\(x\s*=>\s*x\.(\w+)\)");
                if (propertyMatch.Success)
                {
                    var propertyName = propertyMatch.Groups[1].Value;
                    if (!ruleChains.ContainsKey(propertyName))
                    {
                        ruleChains[propertyName] = new RuleChainInfo();
                    }
                }
            }
            // Look for validation method calls
            else if (line.Contains(".NotEmpty()"))
            {
                // Find the current property being configured
                var currentProperty = ruleChains.Keys.LastOrDefault();
                if (currentProperty != null)
                {
                    ruleChains[currentProperty].Rules.Add("NotEmpty");
                }
            }
            else if (line.Contains(".Length("))
            {
                var currentProperty = ruleChains.Keys.LastOrDefault();
                if (currentProperty != null)
                {
                    var lengthRule = ExtractLengthRule(line);
                    if (lengthRule != null)
                    {
                        ruleChains[currentProperty].Rules.Add(lengthRule);
                    }
                }
            }
            else if (line.Contains(".Email()"))
            {
                var currentProperty = ruleChains.Keys.LastOrDefault();
                if (currentProperty != null)
                {
                    ruleChains[currentProperty].Rules.Add("Email");
                }
            }
            else if (line.Contains(".InclusiveBetween("))
            {
                var currentProperty = ruleChains.Keys.LastOrDefault();
                if (currentProperty != null)
                {
                    var rangeRule = ExtractRangeRule(line);
                    if (rangeRule != null)
                    {
                        ruleChains[currentProperty].Rules.Add(rangeRule);
                    }
                }
            }
            else if (line.Contains(".WithMessage("))
            {
                var currentProperty = ruleChains.Keys.LastOrDefault();
                if (currentProperty != null)
                {
                    var message = ExtractCustomMessage(line);
                    if (!string.IsNullOrEmpty(message))
                    {
                        ruleChains[currentProperty].Message = message;
                    }
                }
            }
        }

        // Generate validation code
        foreach (var kvp in ruleChains)
        {
            var validationCode = GeneratePropertyValidation(kvp.Key, kvp.Value.Rules, kvp.Value.Message, targetType);
            sb.AppendLine(validationCode);
            sb.AppendLine();
        }

        return sb.Length > 0 ? sb.ToString() : "// No validation rules found";
    }

    /// <summary>
    /// Parses fluent validation rules from Roslyn syntax tree.
    /// </summary>
    private static string ParseFluentValidationFromSyntax(BlockSyntax methodBody, ITypeSymbol targetType)
    {
        var sb = new StringBuilder();
        var statements = methodBody.Statements.ToArray();

        // Group statements by RuleFor chains
        var ruleChains = new Dictionary<string, RuleChainInfo>();

        string? currentProperty = null;

        foreach (var statement in statements)
        {
            if (statement is ExpressionStatementSyntax exprStmt)
            {
                var result = ParseExpressionStatement(exprStmt.Expression);
                if (result != null)
                {
                    var (property, rule, message) = result.Value;

                    if (!string.IsNullOrEmpty(property))
                    {
                        currentProperty = property;
                        if (!ruleChains.ContainsKey(property))
                        {
                            ruleChains[property] = new RuleChainInfo();
                        }
                    }

                    if (!string.IsNullOrEmpty(currentProperty) && !string.IsNullOrEmpty(rule))
                    {
                        ruleChains[currentProperty].Rules.Add(rule);
                    }

                    if (!string.IsNullOrEmpty(currentProperty) && !string.IsNullOrEmpty(message))
                    {
                        ruleChains[currentProperty].Message = message;
                    }
                }
            }
        }

        // Generate validation code for each property
        foreach (var kvp in ruleChains)
        {
            var validationCode = GeneratePropertyValidation(kvp.Key, kvp.Value.Rules, kvp.Value.Message, targetType);
            sb.AppendLine(validationCode);
            sb.AppendLine();
        }

        return sb.Length > 0 ? sb.ToString() : "// No validation rules found";
    }

    /// <summary>
    /// Helper class for rule chain information.
    /// </summary>
    private sealed class RuleChainInfo
    {
        public List<string> Rules { get; } = new();
        public string Message { get; set; } = "";
    }

    /// <summary>
    /// Parses an expression statement and returns (property, rule, message) if applicable.
    /// </summary>
    private static (string? property, string? rule, string? message)? ParseExpressionStatement(ExpressionSyntax expression)
    {
        // Handle chained calls like: RuleFor(x => x.Name).NotEmpty()
        if (expression is InvocationExpressionSyntax invocation)
        {
            return ParseInvocationChain(invocation);
        }

        return null;
    }

    /// <summary>
    /// Parses a chain of invocations like RuleFor(...).NotEmpty().Length(...)
    /// </summary>
    private static (string? property, string? rule, string? message)? ParseInvocationChain(InvocationExpressionSyntax invocation)
    {
        // Find the leftmost part of the chain (the RuleFor call)
        var ruleForInvocation = FindRuleForInChain(invocation);
        if (ruleForInvocation == null)
            return null;

        // Extract property from RuleFor
        var property = ExtractPropertyFromRuleFor(ruleForInvocation);
        if (string.IsNullOrEmpty(property))
            return null;

        // Extract the specific rule from this invocation
        var rule = ExtractRuleFromInvocation(invocation);
        var message = ExtractMessageFromInvocation(invocation);

        return (property, rule, message);
    }

    /// <summary>
    /// Finds the RuleFor invocation in a chain.
    /// </summary>
    private static InvocationExpressionSyntax? FindRuleForInChain(InvocationExpressionSyntax invocation)
    {
        var current = invocation;

        while (current.Expression is MemberAccessExpressionSyntax memberAccess)
        {
            if (memberAccess.Name.Identifier.Text == "RuleFor")
            {
                return current;
            }

            if (memberAccess.Expression is InvocationExpressionSyntax innerInvocation)
            {
                current = innerInvocation;
            }
            else
            {
                break;
            }
        }

        return null;
    }

    /// <summary>
    /// Extracts property name from RuleFor invocation.
    /// </summary>
    private static string? ExtractPropertyFromRuleFor(InvocationExpressionSyntax ruleForInvocation)
    {
        var args = ruleForInvocation.ArgumentList.Arguments;
        if (args.Count != 1)
            return null;

        var lambda = args[0].Expression as SimpleLambdaExpressionSyntax;
        var memberAccess = lambda?.Body as MemberAccessExpressionSyntax;

        return memberAccess?.Name.Identifier.Text;
    }

    /// <summary>
    /// Extracts the rule type from an invocation.
    /// </summary>
    private static string? ExtractRuleFromInvocation(InvocationExpressionSyntax invocation)
    {
        var methodName = GetMethodName(invocation);
        if (string.IsNullOrEmpty(methodName))
            return null;

        switch (methodName)
        {
            case "RuleFor":
                return null; // Skip RuleFor itself
            case "NotEmpty":
                return "NotEmpty";
            case "Length":
                return ParseLengthArguments(invocation);
            case "Email":
                return "Email";
            case "InclusiveBetween":
                return ParseRangeArguments(invocation);
            case "Must":
                return "Must:custom";
            case "When":
                return "When:condition";
            case "RequiredIf":
                return "RequiredIf:condition";
            default:
                return null;
        }
    }

    /// <summary>
    /// Extracts custom message from WithMessage invocation.
    /// </summary>
    private static string? ExtractMessageFromInvocation(InvocationExpressionSyntax invocation)
    {
        var methodName = GetMethodName(invocation);
        if (methodName == "WithMessage")
        {
            return ParseWithMessageArgument(invocation);
        }
        return null;
    }



    /// <summary>
    /// Extracts length validation parameters.
    /// </summary>
    private static string? ExtractLengthRule(string line)
    {
        var match = System.Text.RegularExpressions.Regex.Match(line, @"\.Length\((\d+),\s*(\d+)\)");
        if (match.Success)
        {
            var min = match.Groups[1].Value;
            var max = match.Groups[2].Value;
            return $"Length:{min}:{max}";
        }
        return null;
    }

    /// <summary>
    /// Extracts range validation parameters.
    /// </summary>
    private static string? ExtractRangeRule(string line)
    {
        var match = System.Text.RegularExpressions.Regex.Match(line, @"\.InclusiveBetween\(([^,]+),\s*([^)]+)\)");
        if (match.Success)
        {
            var min = match.Groups[1].Value.Trim();
            var max = match.Groups[2].Value.Trim();
            return $"Range:{min}:{max}";
        }
        return null;
    }

    /// <summary>
    /// Extracts custom error message.
    /// </summary>
    private static string ExtractCustomMessage(string line)
    {
        var match = System.Text.RegularExpressions.Regex.Match(line, @"\.WithMessage\(""(.*)""\)");
        return match.Success ? match.Groups[1].Value : "";
    }

    /// <summary>
    /// Gets the method name from an invocation expression.
    /// </summary>
    private static string? GetMethodName(InvocationExpressionSyntax invocation)
    {
        if (invocation.Expression is MemberAccessExpressionSyntax memberAccess)
        {
            return memberAccess.Name.Identifier.Text;
        }
        return null;
    }

    /// <summary>
    /// Parses Length method arguments.
    /// </summary>
    private static string? ParseLengthArguments(InvocationExpressionSyntax invocation)
    {
        var args = invocation.ArgumentList.Arguments;
        if (args.Count == 2 &&
            args[0].Expression is LiteralExpressionSyntax minLiteral &&
            args[1].Expression is LiteralExpressionSyntax maxLiteral &&
            minLiteral.Kind() == SyntaxKind.NumericLiteralExpression &&
            maxLiteral.Kind() == SyntaxKind.NumericLiteralExpression)
        {
            var min = minLiteral.Token.ValueText;
            var max = maxLiteral.Token.ValueText;
            return $"Length:{min}:{max}";
        }
        return null;
    }

    /// <summary>
    /// Parses InclusiveBetween method arguments.
    /// </summary>
    private static string? ParseRangeArguments(InvocationExpressionSyntax invocation)
    {
        var args = invocation.ArgumentList.Arguments;
        if (args.Count == 2)
        {
            var minExpr = args[0].Expression.ToString();
            var maxExpr = args[1].Expression.ToString();
            return $"Range:{minExpr}:{maxExpr}";
        }
        return null;
    }

    /// <summary>
    /// Parses WithMessage method argument.
    /// </summary>
    private static string ParseWithMessageArgument(InvocationExpressionSyntax invocation)
    {
        var args = invocation.ArgumentList.Arguments;
        if (args.Count == 1 &&
            args[0].Expression is LiteralExpressionSyntax literal &&
            literal.Kind() == SyntaxKind.StringLiteralExpression)
        {
            return literal.Token.ValueText.Trim('"');
        }
        return "";
    }



    /// <summary>
    /// Generates validation code for a single property.
    /// </summary>
    private static string GeneratePropertyValidation(string propertyName, List<string> rules, string customMessage, ITypeSymbol targetType)
    {
        var sb = new StringBuilder();
        var propertyType = GetPropertyType(targetType, propertyName);
        var isString = propertyType?.SpecialType == SpecialType.System_String;
        var message = string.IsNullOrEmpty(customMessage) ? GenerateDefaultMessage(propertyName, rules) : customMessage;

        // Generate validation logic based on rules
        foreach (var rule in rules)
        {
            if (rule == "NotEmpty")
            {
                if (isString)
                {
                    sb.AppendLine($"            if (string.IsNullOrEmpty(instance.{propertyName}))");
                    sb.AppendLine("            {");
                    sb.AppendLine($"                result.Errors.Add(new ValidationError(\"{propertyName}\", \"{message}\", Severity.Error));");
                    sb.AppendLine("            }");
                }
            }
            else if (rule.StartsWith("Length:", System.StringComparison.Ordinal))
            {
                var parts = rule.Split(':');
                if (parts.Length >= 3 && int.TryParse(parts[1], out var min) && int.TryParse(parts[2], out var max))
                {
                    sb.AppendLine($"            if (instance.{propertyName} != null && (instance.{propertyName}.Length < {min} || instance.{propertyName}.Length > {max}))");
                    sb.AppendLine("            {");
                    sb.AppendLine($"                result.Errors.Add(new ValidationError(\"{propertyName}\", \"{message}\", Severity.Error));");
                    sb.AppendLine("            }");
                }
            }
            else if (rule == "Email")
            {
                sb.AppendLine($"            if (!string.IsNullOrEmpty(instance.{propertyName}) && !instance.{propertyName}.Contains(\"@\"))");
                sb.AppendLine("            {");
                sb.AppendLine($"                result.Errors.Add(new ValidationError(\"{propertyName}\", \"{message}\", Severity.Error));");
                sb.AppendLine("            }");
            }
            else if (rule.StartsWith("Range:", System.StringComparison.Ordinal))
            {
                var parts = rule.Split(':');
                if (parts.Length >= 3)
                {
                    var min = parts[1];
                    var max = parts[2];
                    sb.AppendLine($"            if (instance.{propertyName} < {min} || instance.{propertyName} > {max})");
                    sb.AppendLine("            {");
                    sb.AppendLine($"                result.Errors.Add(new ValidationError(\"{propertyName}\", \"{message}\", Severity.Error));");
                    sb.AppendLine("            }");
                }
            }
            // Add more rule handlers as needed
        }

        return sb.ToString().TrimEnd();
    }

    /// <summary>
    /// Gets the type of a property from the target type.
    /// </summary>
    private static ITypeSymbol? GetPropertyType(ITypeSymbol targetType, string propertyName)
    {
        if (targetType is INamedTypeSymbol namedType)
        {
            var property = namedType.GetMembers()
                .OfType<IPropertySymbol>()
                .FirstOrDefault(p => p.Name == propertyName);
            return property?.Type;
        }
        return null;
    }

    /// <summary>
    /// Generates a default error message based on the rules.
    /// </summary>
    private static string GenerateDefaultMessage(string propertyName, List<string> rules)
    {
        if (rules.Contains("NotEmpty"))
            return $"The {propertyName} field is required.";

        if (rules.Any(r => r.StartsWith("Length:", System.StringComparison.Ordinal)))
            return $"The {propertyName} field has invalid length.";

        if (rules.Contains("Email"))
            return $"The {propertyName} field must be a valid email address.";

        if (rules.Any(r => r.StartsWith("Range:", System.StringComparison.Ordinal)))
            return $"The {propertyName} field is outside the valid range.";

        return $"The {propertyName} field is invalid.";
    }

    #endregion
}

/// <summary>
/// Information about a fluent validator configuration.
/// </summary>
internal sealed class FluentValidatorConfigInfo
{
    public INamedTypeSymbol ConfigClass { get; }
    public ITypeSymbol TargetType { get; }
    public string? MethodBody { get; }

    public FluentValidatorConfigInfo(INamedTypeSymbol configClass, ITypeSymbol targetType, string? methodBody)
    {
        ConfigClass = configClass;
        TargetType = targetType;
        MethodBody = methodBody;
    }
}
